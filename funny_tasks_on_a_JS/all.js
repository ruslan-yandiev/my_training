// ! Задачки: https://gist.github.com/codedokode/ce30e7a036f18f416ae0

/*
! Все функции-конструкторы (экземпляры), созданные с помощью 'new', будут иметь тип 'object'
var str = new String('String');
var num = new Number(100);

typeof str; // Вернёт 'object'
typeof num; // Вернёт 'object'

! Но существует исключение для конструктора Function

var func = new Function();

typeof func; // Вернёт 'function'

! Это было определено с рождения JavaScript
typeof null === 'object';

!Исключения
!Во всех текущих браузерах существует нестандартный host-объект document.all, который имеет тип Undefined.

typeof document.all === 'undefined';
*/
// *========================================================================================================
/*
! Все свойства(ключи) в объекте приводятся к строке.

! Объект сортирует свои свойства выставляя сначала положительные-целочисленные значение по возрастанию
! а затем выставит все остальные по порядку создания(добавления) в объект(е)
*/
let obj = {
  "2asd": "2asd",
  35: 35,
  333: 333,
  90: 90,
  22: 22,
  "-1": -1,
  1: 1,
};
console.log(Object.keys(obj)); //['1', '22', '35', '90', '333' '2asd', '-1']
//* ========================================================================================================

// TODO Самый быстрый математический способ получить ближайшее целое число без остатка делящееся на 5
function round5(val) {
  // ! используя математический объект округлим деление числа val на 5, и умножаем на 5
  // математическая формула для получения ближайшего целого числа, можно и на 2, 3, 4...
  return Math.round(val / 5) * 5;
}

//* ========================================================================================================
const arr = [3, 7, 15, 18, 22, 47];
arr.sort(); // ! изменяет исходный массив всегда. отсортирует подефолту как строки по первому символу. исправить передав колбек с кодом arr.sort((a, b) => a > b) или arr.sort((a, b) => a - b);
console.log(arr); // [15, 18, 22, 3, 47, 7]
//* ========================================================================================================
/*
Карирование
*/
// ! Использовали ЗАМЫКАНИЯ. Возвращали новую функцию которая по очереди принимала параметры и
// ! плюсовала к счетчику currentValue в созданном нами замыкании(области видимости) КАРРИРОВАНИЕ
function add(num) {
  if (!num) return 0;

  return function f(number) {
    if (!number) return num;
    num += number;
    return f;
  };
}

console.log(add()); // 0
console.log(add(2)(1)()); // 3
console.log(add(5)(-1)(2)()); // 6

// ! рекурсивный вариант
function add(num) {
  if (num === undefined) return 0;

  return function (num2) {
    if (num2 === undefined) return num;
    num += num2;
    return add(num);
  };
}

console.log(add()); // 0
console.log(add(10)()); // 10
console.log(add(2)(1)()); // 3
console.log(add(5)(-1)(2)()); // 6
//* =======================================================================================================
/*
В функцию sumAge передается структура, в которой описан человек и его дети.
Функция должна возвращать сумму возрвста человека и сумму возрвстов всех его детей.
*/
function sumAge(user) {
  let sum = user.age;
  // !  (?) тут выполняет схожую работу как и в ruby не позволяя выбросить исключение если будет undefined
  for (let i = 0; i < user.children?.length; i++) {
    sum += sumAge(user.children[i]);
  }
  return sum;
}

// ! хорошее решение с рекурсией
const sumAge = (user) => (user.children ? user.children.reduce((sum, child) => sum + sumAge(child), user.age) : user.age);

const user = {
  name: "Петр",
  age: 49,
  children: [
    {
      name: "Nina",
      age: 25,
      children: [
        {
          name: "Andray",
          age: 3,
        },
        {
          name: "Oleg",
          age: 1,
        },
      ],
    },
    {
      name: "Aleksandr",
      age: 22,
    },
  ],
};

console.log(sumAge(user));
//* =====================================================================================================

const btn = document.getElementById("my-btn");

btn.addEventListener("click", () => {
  setTimeout(() => console.log("setTimeout 1"));
  Promise.resolve().then(() => console.log("Promise 1"));
  console.log("console.log 1");
});

btn.addEventListener("click", () => {
  setTimeout(() => console.log("setTimeout 2"));
  Promise.resolve().then(() => console.log("Promise 2"));
  console.log("console.log 2");
});

btn.click();
/*
При програмном вызове фугкций обработки событий btn.click() в консоль будет выведено:
console.log 1
console.log 2

Promise 1
Promise 2

setTimeout 1
setTimeout 2

console.log это просто код и он исполняется первым в порядке инициализации.
Сам же обрабодчик событий Это таска(макро таска) - которая выполняется последней после того как выпонятся все микро таски
Promise (зарезервреный resolve) - это как я понял микро таска выполняем его после всех console.log и любого обычного кода.
setTimeout это таска (макро таска) выполняется отдельно последними.

Если же мы в браузере кликним на кнопку, то в консоль уже выведится другой результат выполнения:
console.log 1
Promise 1

console.log 2
Promise 2

setTimeout 1
setTimeout 2

click - при клике через браузер эта таска (макро таска) будет выполняться сначала код в первой фынкции обработчика событий. console.log в просто код пойдет первым
на выполнение, затем выполнятся все микро таски  Promise 1 (зарезервреный resolve), а setTimeout 1 встанет в очередь на выполнение так как таска(макро таска).
Когда завершается Таска (макро таск) то выполняются все накомпленные микротаски (которые были инициализированны внутри него какя понял)
Затем начнется выполняться код во втором обработчике по той же схеме console.log 2 и затем промис Promise 2, а setTimeout 2 встанет в
очередь на исполнение за setTimeout 1 и начнут выполняться когда весь основной код и микро таски будут выполнены.
*/

//* =======================================================================================================================================
/*
? const array = [1, 2];
? что будет если массиву указать длину больше, чем элементов в нем array.length = 100
?     - Отвечаю, что массив заполнится элементами в значении undefined.


!Вообще говоря у элементов действительно будет значение undefined. Но в комментах была замечательная поправка: массив на самом деле заполнится пустыми ячейками, у которых уже будет значение undefined.
!Это важное отличие, потому что такие ячейки будут пропускаться в циклах map, forEach и т.д.

!А такой undefined пропущен не будет
!const array = [1, 2, undefined]; 
*/

//* ========================================================================================================================================

/*
    Если захотим удалить все элементы из массива или часть элементов отсекая их с конца, и оставить при это м тот же массив(объект) в ячейке памяти
    то:
    const arr = [1, 2, 3, 4, 5];
    arr.length = 2;
    console.log(arr) // [1, 2];
*/

//* ========================================================================================================================================

/*
    ! Декларативный или функциональный подход в программировании отвечает на вопрос: Что нужно сделать в рамках кода (что мы хотим сделать) (перебрать массив, отсортировать, вывести)
    ! Императивный подход отвечает в первую очередь на вопрос: как это нужно сделать (как именно перебираем массив контроль всего процесса перебора, как отсортировать его, как вывести)
*/
//* ========================================================================================================================================

/*
   ! CORS - Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.
*/
//* ========================================================================================================================================

function func() {
  console.log(this);
}

const person = {
  name: "Andray",
};

func.bind(person)(); // с помощью бинд принудительно задали контекст вызова функции в рамках объекта person, а не Window
func(); // контекст вызова  Window если не задан 'use strict' иначе undefined
const bindedFunct = func.bind(person); // забиндили контекст вызова функции и сохранили эту функцию с этим контекстом в новой переменной, для повторного использования
bindedFunct(); // контекст person

//* ========================================================================================================================================

/*
Реализовать метод sum
*/
// для любого созданного объекта массива в программе
Array.prototype.sum = function () {
  return this.reduce((accum, elem) => accum + elem);
};

const arr = [1, 2, 3, 4, 5];
const sum = arr.sum();
console.log(sum);

// только для одного массива arr
arr.sum2 = function () {
  return this.reduce((accum, elem) => accum + elem);
};
const sum2 = arr.sum2();
console.log(sum2);
const arr2 = [1, 2, 3, 4, 5];
console.log(arr2.sum()); // 15
// console.log(arr2.sum2()); //  arr2.sum2 is not a function

//* ========================================================================================================================================

/*
	* 1) shadow-dom - это у элемента может быть свой теневой дом в котором есть свои div и стили которые не выходят за приделы этого элемента
		* это веб технология для определения области видимости переменных css и веб компонентов

	* 2) LIFO и FIFO - LIFO(последний пришел, первый ушел (СТЕК)) когда вызываем функцию, внутри нее вызываем другую функцию и в нутри нее вызываем другую функцию, то вызовы будут изнутри на ружу
		*    FIFO(первый пришел, первый ушел (ОЧЕРЕДЬ)) класитческая очередь f1().f2().f3() f1 первый вернет результат выполнения и далее по очереди.

	* 3) Что такое полифилл - помогает сделать нам доступные свойства для разных браузеров.

	* 4) Что такое CDN - это специальный сервер который используется для уменьшения времени загрузки данных. На пример загрузка гугл шрифтов, если на пример клиент очень далеко от основного сервера
		* то сервер может перенаправить клиента для загрузки крупных данных на ближайший к клиенту CDN сервер и подгружать эти данные к клиенту с него.

	* 5) Web-worker - это фактически полноценный отдельный поток помогающий загружать или выполнять какуюто работу (сложные вещи) в браузере в реальном времени не подвисая страницу.
		* это отдельный скрипт запускаемый в отдельном потоке, на заднем фоне не тормозястраницу и работает на заднем плане.

    * 6) IIFE (Immeiate Invoked Function Expression) - Функция которая при инициализации немедленно выполнятся (Function(arg,...){....})(arg,...);
*/

//* ========================================================================================================================================

/*
	*1) Тег datalist позволяет создать список автодополнения

	*2) Мы js скрипты в html обычно подключаем в body, но есть вариант подключить в head
		* такие скрипты с атрибутами в теге как async и defer
		* async позволит паралельно подгрузать js скрипты в отдельном потоке вместе с html и исполнять его прогруженную чать
		* defer подгружает скрипт в паралельном потоке, но скрипт будет исполняться только после полной его загрузки и втом порядке котором мы указали вне зависимости кто первый загрузится

	*3) Object.freeze(obj) - заморозит объект и его никогда нельзя будет изменить
*/

//* ========================================================================================================================================

/*
 ! Дескрипторы свойств, присутствующие в объектах, бывают двух основных типов: дескрипторы данных и дескрипторы доступа. 
 ! Дескриптор данных — это свойство, имеющее значение, которое может быть (а может и не быть) записываемым. 
 ! Дескриптор доступа — это свойство, описываемое парой функций — геттером и сеттером.
*/

//* ========================================================================================================================================

/*
 * '1 a-г ***    (...333'.replace(/[^а-я]+/g, '') 'aг' // вс что не от а до я мы убираем (заменяем на пустую строку-убираем)
 */

//* ========================================================================================================================================

// выведите 1, если первый аргумент есть, и 0 - если нет
function f(x) {
  return arguments.length ? 1 : 0;
}

console.log(f(undefined)); // 1
console.log(f()); // 0

// Напишите функцию sum(...), которая возвращает сумму всех своих аргументов:
function sum(a) {
  if (!arguments.length) return 0;
  return Array.from(arguments).reduce((acc, el) => acc + el);
}

console.log(sum()); // 0
console.log(sum(1)); // 1
console.log(sum(1, 2)); // 2
console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4)); // 10

//* ========================================================================================================================================

/*
	* 1) zz = 99 // при 'use strict' будет ошибка, а иначе будет присвоено глобальному window.zz = 99
		* console.log(zz);
	
	* 2) Какой селектор использовать для выбора input'ов с типом radio? - input[type="radio"] можем по присваивать стили как всем тегам так и отсеять по одному из атрибутов

	* 3) Спрайты, что это такое? - Когда есть к примеру множество картинок смайликов и для оптимизации загрузки
		* объединим картинки в одну большую картинку из множества смайлов и стилями выберем нужный нам смайл по пикселям

	* 4) Как получить url в чистом javascript? - а) document.URL   b) window.location.href

	* 5)  Что такое IIFE? - когда делаем самовызывающуюся функцию обернув ее (код функции)() и ее самовызов.

	* 6) package-lock.json для чего он нужен? - при работе с npm, будет хранить все покеты версий которые мы подтягивали
		* чтобы при командной разработки можно будет согласовать одни и те же версии библиотек
		* То есть хранин все версии подтянутых библиотек и все зовисимости между друг другом
*/

//* ========================================================================================================================================

Math.floor(Math.random() * 10) + 1; //! случайное целое число от минимального включительно и до максимального включительно от 1 до 10

//* ========================================================================================================================================

/*
    * 1) placeholder-shown псевдокласс, для чего он? - когда виден placeholder он показывает или подсвечивает нужным цветом если бэеграунд задан, а когда начинаем заполнять поле, то исчезает

    * 2)  1 < 2 < 3 // true;  3 > 2 > 1 false; - потому что (true) преобрауется в (1) а (false) в (0)
*/

//* ========================================================================================================================================

/*
В JS есть два вида свойств.
Первые обычные свойства, вторые свойства ассессоры.
У обычных свойств(ключей) имеются 4 дескриптора: ("value": 'тут должно быть значение в виде примитива или объектного типа---функции, объекты, массивы....', 
"writable":  true или false (по умолчанию true что позволит перезаписывать значение свойства. соответственно false запретит делать перезапись ив строгом режиме выбросит исключение, а не в строгом просто проигнорирует операцию нового присвоения),  
"enumerable": true или false (по умолчанию true, что позволяет перебирать свойство в цикле и false не позволит этого),  
"configurable": true или false (изначально ture, что позволяет нам удалять свойство, если установить false то обратной дороги не будет, свойство уже будет навсегда неизменным и 
специальными методами Object.defineProperty() нам уже никак не изменить свойство вообще, практически аналог заморозки свойства объекта)ю
У свойств объекта Ассесоров имеются 4 дескриптора: функция get (которая возвращает значение), функция set (которая принимает один аргумент и возвращает undefined), "enumerable": (работает аналогично для обоих видов свойств), 
"configurable":  (работает аналогично для обоих видов свойств), дескриптора значения у свойства ассесора нет.
Для того, чтобы установить свойства ассесоры для экземпляра функции конструктора необходимо пользоваться спектральными методами:  Object.defineProperty() и Object.defineProperties()-позволяет определить множество свойств сразу()
Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).
Для классов все упрощено и можно устанавливать геттеры и сеттеры сразу прописав get name() {....}
Впрочем геттеры и сеттеры можно заменить на простые методы, но придется делать вызов функции и задавать условие. что если значение аргумента не передано то провести операцию по возврату значения, 
а если значение аргумента при вызове функции передано то провести операцию set и вернуть undefined. Думаю это имитируется поведение геттера и сеттера с использованием одного имени метода экземпляра класса, 
но такой подход не верный с точки зрения SOLID так как нарушается принцип единственной обязанности функции.
*/

function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // возраст рассчитывается из текущей даты и дня рождения
  // ! один из способов устанавливать геттер и сеттер в конструкторе, да и любые свойства
  Object.defineProperty(this, "age", {
    get() {
      return new Date().getFullYear() - this.birthday.getFullYear();
    },
  });
}

let john = new User("John", new Date(1992, 6, 1));

alert(john.birthday); // доступен как день рождения
alert(john.age); // ...так и возраст

// ! классовый аналог
class User2 {
  constructor(name, birthday) {
    this.name = name;
    this.birthday = birthday;
  }

  get age() {
    return new Date().getFullYear() - this.birthday.getFullYear();
  }
}

let john2 = new User2("John2", new Date(1992, 6, 1));

alert(john2.birthday); // доступен как день рождения
alert(john2.age); // ...так и возраст

// ============================================================================

function Score() {
  this.arr = [];
  this.one = 0;
  this.two = 0;

  Object.defineProperty(this, "firstPlayerScore", {
    set(arg) {
      this.one = arg;
      this.arr.push({ firstPlayerScore: this.one, secondPlayerScore: this.two });
    },

    get() {
      return this.one;
    },
  });

  Object.defineProperty(this, "secondPlayerScore", {
    set(arg) {
      this.two = arg;
      this.arr.push({ firstPlayerScore: this.one, secondPlayerScore: this.two });
    },

    get() {
      return this.two;
    },
  });

  this.getHistory = function () {
    return this.arr;
  };
}
const score = new Score();
score.firstPlayerScore = 1;
score.firstPlayerScore = 2;
score.secondPlayerScore = 1;
console.log(score.getHistory());
console.log(score.firstPlayerScore);
console.log(score.secondPlayerScore);

//* ========================================================================================================================================

/*
 * 1) JWT (правильно - JSON Web Token, а я назвал JavaScript Web Token'ом, виноват  - что это?
 * Это не хэш токена, там хэшируется только сумма (чтобы сервер мог свериться с с суммой и подтвердить
 * что не было подмены токена), но при этом он в себе хранит обычные данные, например id пользователя,
 * имя или что-то еще (что захочешь) и эти данные не захешированы, по сути их любой может получить и прочитать.
 * Суть в том, что используя такой токен на стороне сервера не нужно будет лезть в БД для проверки этого токена, достаточно
 * просто проверить сумму, это очень удобно при использовании микросервисов.

 *  2) Чем отличаются односвязный список и двусвязный список? тем, что односвязный хранит в ячейке данне и информацию о месте нахождения следующей ячейке в списке,
        * а если следующей нет то хранит просто сами данные и NULL вместо адреса следующей.
        * Двусвязный список все тоже самое что односвязные, плюс хранит информацию о месте нахождения предыдущей ячейки памяти и если предыдущей нет то будет адрес будет NULL

 * 3) Сервис Воркеры в JS - В идеале, правильная организация взаимодействия приложения с сервис-воркером и кэшем позволит пользователю нормально работать с приложением даже без подключения к сети.
 *          В целом можно сказать, что сервис-воркеры — это разновидность веб-воркеров, а если точнее, то они похожи на разделяемые воркеры. 
 *          В частности, можно выделить следующие важные особенности сервис-воркеров:

 *           Они выполняются в собственном глобальном контексте, ServiceWorkerGlobalScope.
 *           Они не привязаны к конкретной странице.
 *           Они не имеют доступа к DOM.

 *           Особого внимания API сервис-воркеров заслуживает по той причине, что оно позволяет приложениям поддерживать оффлайновые сценарии работы, давая программисту полный контроль над тем, как приложение взаимодействует с внешними ресурсами.
 *           Более подробно:  https://developer.mozilla.org/ru/docs/Web/API/Cache
*/

//* ========================================================================================================================================

for (var i = 0; i < 10; ++i) {
  setTimeout(() => console.log(i), 1000);
} // через секунду вернет 10 десяток, так как var имеет функуиональную область видимости и всплывет иницализировавшить в undefided

for (let i = 0; i < 10; ++i) {
  setTimeout(() => console.log(i), 1000);
} // секунду выведит цифры от 0 до 9, так как let имеет блочную область видимости и будет инициализироваться при каждом
// проходжении цикла. То есть let будет объявленно для конкретного замыкания(области видимости исключительно для цикла)

//* ========================================================================================================================================

/*
    * 1) Вопрос про margin и flex - если родителю задан flex, то у первого дочернего элемента margin bottom 10px и следующего
        * дочернего элемента с значением margin top 20px значения внешних отступов сложатся и растояние между ними будет 30px.
        * Если же у родителя не задан flex то  marginы схлопнутся наехав один на другой и растояние между дочерними элементами будет 20px.

    * 2) Как проверить что в переменной массив? Вызвать Array.isArray(передать переменныю для проверки)

    * 3) Как проверить что в объекте есть свойство? {наш объект}.hasOwnProperty('asd') - вернет true если есть такое зсвойство(ключ) ищет свойство только у этого объекта и не лезет в прототип
        * "asd" in {наш объект}  - вернет истину или лож, будет искать свойство(ключ) и в самом объекте и всех прототипах по цепочке наследования.
        * Третий способ: Object.keys(object).includes('key')
*/

//* ========================================================================================================================================

function f() {
  console.log("Hi Ruslan");
}

window.f(); // Hi Ruslan
new f(); // Hi Ruslan
f(); // Hi Ruslan

//* ========================================================================================================================================

/*
    ? 1) HOC в реакте использовал?
        * HOC это элемент который возвращает другой элемент немного переделанный(тоесть он оборачивает, как дикоратор функция)
    
    ? 2) Для чего ставим ключи в реакте при выводе списка?
        * могут быть ошибки и проблемы если не поставить ключи
    
    ? 3) Как сообщить о том что у пользователя выключен JavaScript?
        * В HTML есть тег <noscript>Вруби JS утырок!!!</noscript> 

    ? 4) Какие дескрипторы для свойств объектов есть?
        * get, set, readable, writable, configurable

    ? 5) Что такое функции-генераторы? (function* a {yield "Привет"; yield "Пока";})
        * Обычные функции возвращают только одно-единственное значение (или ничего).
        * Генераторы могут порождать (yield) множество значений одно за другим, 
        * по мере необходимости. Генераторы отлично работают с перебираемыми объектами 
        * и позволяют легко создавать потоки данных.
        * Функции-генераторы ведут себя не так, как обычные. 
        * Когда такая функция вызвана, она не выполняет свой код. 
        * Вместо этого она возвращает специальный объект, так называемый «генератор», 
        * для управления её выполнением.
        * Подробнее о генераторе: https://learn.javascript.ru/generators

    ? 4) Какие группы ответов в http, за что отвечают?
        * Имеется группа ответов о статусе 200, 201, 400, 404, 403, 500 ....
    
    ? 4) Про паттерны.т?
        * Одиночка, стратегия, фабрики, абстрактные фабрики, дикораторы (адаптор) 
*/

//* ========================================================================================================================================

let a;
console.log(a); // undefined
console.log(b); // not defined

//* ========================================================================================================================================

/*
Дан массив вида `[1, 2, [3,4,[5]], 6, 7, [[8]]]`, необходимо получить массив
без вложенных массивов, то есть: `[1, 2, 3, 4, 5, 6, 7, 8]`.
*/
let arr = [1, 2, [3, 4, [5]], 6, 7, [[8]]];

// решение 1
function compact(arr) {
  return [...[].concat.apply([], arr).join("")].map((e) => +e);
}

console.log(compact(arr));

//! решение 5
function compact(arr) {
  return arr.reduce((acc, el) => {
    Array.isArray(el) ? acc.push(...compact(el)) : acc.push(el);
    return acc;
  }, []);
}

console.log(compact(arr));

// решение 2
function compact2(arr) {
  const newArr = [];

  function extractElement(arg) {
    for (let i = 0; i < arg.length; i++) {
      if (Array.isArray(arg[i])) {
        extractElement(arg[i]);
      } else {
        newArr.push(arg[i]);
      }
    }
    return newArr;
  }

  return extractElement(arr);
}

console.log(compact2(arr));

//! решение 3
function compact3(arr) {
  return arr.flat(Infinity);
}

console.log(compact3(arr));

// решение 4
function compact4(arr) {
  return arr
    .toString()
    .split(",")
    .map((x) => +x);
}

console.log(compact4(arr));

//* ========================================================================================================================================

//! Обычно локальные переменные хранятся в стеке, а ссылки в куче, во многих языках это реализовано таким образом для скорости работы, думаю внутри js работает все так же.

//* ========================================================================================================================================

//! Отличие двух функций инициализированных как методы объекта.
const obj = {
  name: "Ivan",
  m: function () {},
  m2() {},
};

console.dir(new obj.m()); //! есть свойство prototype - constructor у декларативной функции и она может создавать свои эккземпляры и также быть вызвана
console.dir(new obj.m2()); //! нет свойства prototype - constructor (obj.m2 is not a constructor), нельзя даже вызвать ее с помощью new

//* ========================================================================================================================================

let a = {};
console.log(a instanceof Object); // true // Исключением только созданный объект без прототипа. Когда он не экземпляр класса Object, но объект
let b = new Object();
console.log(b instanceof Object); // true
let c = Object.create(Object.prototype);
console.log(c instanceof Object); // true

// ! Такой способ создания объекта имеет свои преимущества, например, можно быть уверенным,
// ! что в таком объекте будут только те свойства, которые мы туда положим. Можно смело итерироваться по такому объекту.
let d = Object.create(null);
console.log(d instanceof Object); // false // объект создан без прототипа, тоесть не является экземпляром глобального объекта Object
console.log(typeof d); // 'object'

//* ========================================================================================================================================

/*
 * 1) Функции первого порядка - это то, про что в видео говорилось - функция принимает только простые значения или объекты, но не функции.
 * 2) Функции первого класса - это то про что вы описали, когда функция является значением и может быть использована в виде аргументов переданных например в функции высшего порядка.
 * 3) Функция высшего порядка - противоположность функции первого порядка, это функция, которая принимает другую функцию в качестве аргумента или возвращает другую функцию как значение.
 * 4) Функция-монада или унарная функция - это это функция принимающая один аргумент.
 * 5) Карироване - это когда функция принимает аргумент и возвращает другую функцию которая принимает аргументи так до возврата значения (попутно создается замыкание)
 */

//* ========================================================================================================================================
/*
Боксинг
У примитивных значений (примитивные = не-объекты, то есть числа, строки, true/false/null/undefined) нет свойств и методов (они есть только у объектов). 
При попытке обратиться к свойствам/методам примитивов происходит боксинг: яваскрипт создает временный объект из примитива и обращается к нему (сам примитив остается неизменным). 
Для чисел создается объект «класса» Number, для true/false Boolean, для строк — String (вот мы и узнали, зачем были нужны эти встроенные классы). Для null и undefined выдается ошибка. 
То есть код

var a = "abc";
var b = a.length;
*/

var x = 1;
var tmp1 = new Number(x);
tmp1.test = 2; // свойство присвоилось временному объекту
var tmp2 = new Number(x);
console.log("test" in tmp2); // а ищем мы его уже в другом объекте, естественно его там нет

var a = "abc";
var aInABox = new String(a); // ручной боксинг

var fiveInABox = new Number(5);
var five = fiveInABox.valueOf(); // ручной анбоксинг, в five лежит примитив - число 5
//* ========================================================================================================================================

//! Способы копирования объекта Date:
var date = new Date();
var copiedDate = new Date(date.getTime());

var date = new Date();
var copiedDate = new Date(date);

var dat = new Date();

var copyOf = new Date(dat.valueOf());

//* ========================================================================================================================================

// ! дажке два одинаковых символа никогда не равны друг другу ВООБЩЕ.
let a = Symbol();
let b = Symbol();
console.log(a === b); // false
console.log(a == b); // false

//* ========================================================================================================================================

/*
В функцию mostFrequentDays передается год (целое число), необходимо реализовать
функцию так, чтобы из нее вернулся массив с наиболее часто встречаемыми днями
недели в году, что был передан. Массив должен быть отсортирован по дням недели
(от понедельника к воскресенью).

В данном варианте правильные ответы, задача верна.
*/

function mostFrequentDays(year) {
  return new Date(year, 1, 29).getMonth() === 1
    ? [new Date(year, 0, 2), new Date(year, 0, 1)]
        .sort((a, b) => (a.getDay() === 0 ? 7 : a.getDay()) - (b.getDay() === 0 ? 7 : b.getDay()))
        .map((val) => val.toLocaleString("ru", { weekday: "long" }))
    : [new Date(year, 0, 1).toLocaleString("ru", { weekday: "long" })];
}

console.log(mostFrequentDays(2016)); // ["пятница", "суббота"]
console.log(mostFrequentDays(2019)); // ["вторник"]
console.log(mostFrequentDays(2020)); // ["среда", "четверг"]

//* ========================================================================================================================================

/*
Реализовать методы, которые в процессе выполнения строки (2).plus(3).minus(1) 
дали бы на выходе 4.
*/
Number.prototype.plus = function (num) {
  return +this + num;
};

Number.prototype.minus = function (num) {
  return +this - num;
};

// ! если написать 2.plus(3).minus(1) будет ошибка так как js думает, что после числа 2 идет точка не вызова функции
// ! а точка после которой должны идити цифры дроби 2.5 исправить косяк можно скобками или после точки поставить еще точку
// ! (2).plus(3).minus(1) или 2..plus(3).minus(1)
// * нужно отметить, что () создают некий объект обертку и имеют самый высокий приоритет в таблице приоритетов JS
console.log((2).plus(3).minus(1)); // 4

// * =========================================================================
/*
Почему в консоли будет цифра
Ответ: Число которое мы получаем является идентификатором, по которому можно будет прервать выполнение функции
*/
function a(h) {
  return `Дядя ${h}`;
}
console.log(setTimeout(() => a("Дима"), 1000));

//* ========================================================================================================================================

function F1() {}
F1.__proto__.name1 = "Ruslan";
console.log(F1.name1); //Ruslan
Function.prototype.name2 = "Ruslan2"; // и на чтение и на запись
console.log(F1.name2); // Ruslan2

function F2() {}
console.log(F2.name1); //Ruslan
console.log(F2.name2); // Ruslan2

//* ========================================================================================================================================
/*
   ! Когда у готового объекта мы менем его прототип то слетает оптимизация JS MyObject.prototype = {}; MyObject.prototype = MyFunction.prototype;
   
   ! Оптимизация в JS слетает у массивов когда им присваивают нестандартные свойства как простому объекту [].newName = 'Yand', 
   !хоть в JS массив и есть обычный объект, просто оптемизированный под работу типа данных массив
*/

//* ========================================================================================================================================

// Способы перенаправить клиента с одной страницы на другую и чем отличаются?
// Пример:
setTimeout(() => {
  // window.location.href = 'https://google.com'; // тут иметируется переход по ссылке
  // или
  // window.location.replace('https://google.com'); // иметация перенаправления (rederect)
}, 5000); // перенаправим через пять секунд. +-

//* ========================================================================================================================================

// ! Стот напомнить, что у стрелочных функций не просто нет своего контекста, но и они используют контекс места своего вызова и уже не изменяют его даже принудительно(недьзя будет забиндить, эплаить или заколить)

//* ========================================================================================================================================

// *  bind это специальная функция кторая позволяет привязывать контекст и дополнительные аргументы к заданной
// *  исходной функции. Бинд возвращает новую функцию с уже заданным контекстом. Забинденый контекст сменить уже нельзя, он жостко забинден и второй бинд не удастся!!!
// * Пример:
function sayHi() {
  console.log(`${this} hi`);
}

const bindSayHi = sayHi.bind("Ruslan"); // ! тоесть мы у функции ее контексту this присвоили значение Ruslan, ну или можем присвоить в качестве контекста другой объект
bindSayHi(); // Ruslan hi
//* ========================================================================================================================================

// ! Проверка на наличие свойства у объекта:
const obj = {
  a: undefined,
};

console.log("a" in obj); // true (проверяет наличие в том числе унаследованных свойств от родителей по цепочке наследования)
console.log(obj.hasOwnProperty("a")); // true (проверяет только свойства данного объекта, но не унаследованные)
console.log(Object.keys(obj).includes("a")); // true

//* ========================================================================================================================================

const arr = [1, 2, 3];
arr.asd = "Hi man!"; // ! Потеря оптимизации массива

for (let key in arr) {
  console.log(key); // 0, 1, 2, asd
}

//! перечисляет с помощью метода массива (итератором)
for (let key of arr) {
  console.log(key); // 0, 1, 2 //! используя функцию итератора будет выведено только то, что ей передано для итерации (1, 2, 3)
}

// * ==================================================================================================================================

function A() {
  this.a = 1;
  this.b = {
    c: 2,
  };
}

A.prototype = {
  a: 200,
  b: {
    c: 500,
  },
};

const myA = new A();

console.log(myA); // {a: 1, b: {c: 2}} //! все равно в экземпляр передались при создании определенные в теле функции свойства.
console.log(myA.__proto__); // {a: 200, b: {c: 500}} // ! однако A.prototype теперь другой и будет {a: 200, b: {c: 500}}

delete myA.a; // Удалим свойство а у экземпляра
console.log(myA.a); // 200  //! не найдя у себя свойство (а), объект по __proro__ вызовет свойство (а) у объекта конструктора(родителя) A.prototype

delete myA.a; // Удалить так свойство у A.prototype не получится.
console.log(myA.a); // 200

delete myA.__proto__.a; // а так получится )))
console.log(myA.a); // undefined

/*
  !  То есть конструктор или класс (объект) имеющий возможность создавать свои экземпляры, сначала передает своему экземпляру методы и свойства
  !  определенные (инициализированные) в его коде (теле), а только затем ставит экземпляру в качетве родителя сылку ...__proto__
  !  Откуда экземпляр может использовать методы и свойства которых у него нет.
  !  Если JS не находит нужное свойство и метод в самом экземпляре, он лезет выше по линии наследования по ссылке __proto__ и так до Object.prototype
  !  Удалить у объекта можно только то свойство которое вызвано (имеется) напрямую у объекта, а не полученное по наследству от родителя. Ну или удалить у родителя напрямую через delete экземпляр.__proto__.a или delete Родител.prototype.a
*/

// * ==================================================================================================================================

function debounce(f, ms) {
  let detect = true;

  return function (str) {
    if (detect) {
      f(str);
      // f.call(this, str); // * если вдруг потребуется сохранить контекст вызова
      detect = false;
      setTimeout(() => (detect = true), ms);
    }
  };
}

let debounceFunc = debounce(console.log, 1000);
// выполняется немедленно
debounceFunc("MockInterview 1");
// ничего не выполнится, так как не прошло еще 1000 ms с последнего выполнения
debounceFunc("MockInterview 2");
// ничего не выполнится, так как не прошло еще 1000 ms с последнего выполнения
setTimeout(() => debounceFunc("MockInterview 500"), 500);
// Выполнится
setTimeout(() => debounceFunc("MockInterview 1200"), 1200);
// ничего не выполнится, так как не прошло еще 1000 ms с последнего выполнения
setTimeout(() => debounceFunc("MockInterview 1500"), 1500);
// выполнится
setTimeout(() => debounceFunc("MockInterview 2210"), 2210);

// * ==================================================================================================================================

// ! переписать данный код на промисы:
const printSeconds = (number, callback) => {
  setTimeout(() => {
    console.log(`Прошло секунд ${number}`);
    callback();
  }, 1000);
};

printSeconds(1, () => {
  printSeconds(2, () => {
    printSeconds(3, () => {});
  });
});
// мой вариант
new Promise(function (resolve, reject) {
  let time = 0;

  resolve(function (number) {
    setTimeout(() => console.log(`Прошло секунд ${number}`), (time += 1000));
  });
})
  .then((result) => {
    result(1);
    return result;
  })
  .then((result) => {
    result(2);
    return result;
  })
  .then((result) => {
    result(3);
    return result;
  });

// еще вариант
const printSeconds2 = (number) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Прошло секунд ${number}`);
      resolve();
    }, 1000);
  });
};

printSeconds2(1)
  .then(() => {
    return printSeconds2(2);
  })
  .then(() => {
    return printSeconds2(3);
  });

// комбо
const printSeconds = (number) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Прошло секунд ${number}`);
      resolve();
    }, 1000);
  });
};
(async function () {
  await printSeconds(1);
  await printSeconds(2);
  await printSeconds(3);
})();

// такой вариант
async function printSeconds() {
  let time = 0;
  return function (number) {
    setTimeout(() => {
      console.log(`Прошло секунд ${number}`);
    }, (time += 1000));
  };
}
(async function () {
  const start = await printSeconds();
  start(1);
  start(2);
  start(3);
})();

// * ==================================================================================================================================

// ! преобразовать строку в чило:
Number("4");
Number.porseInt(); // но только до целых чисел (он округлит)
+"4";
// ! преобразовать в строку
String(4);
(4).toString();
(4).toString();
"" + 4;

// * ==================================================================================================================================

// Element.innerHTML - будет медленно перерисовывать все объекты дом дерева
//! Element.insertAdjacentHTML - намного быстрее при добавлении эелемента так как не перерисовывает дом древо а просто дабавит новый элемент

// * ==================================================================================================================================

console.log([] == ""); // true // - неявное преобразование к числу 0 == 0 будет true
console.log(Boolean([]) == Boolean[""]); // false // явное преобразование к буливому значению true == false будет false
console.log({} + []); // [object Object] - console.log, а в консоли браузера если ввести то будет 0 (JS овспринимает первую {} как область видимости (блок кода) и плюс пустой массиввот и 0)
console.log([] + {}); // [object Object] всегда
console.log([] + []); // [empty string]
console.log({} + {}); //[object Object] [object Object]

// * ==================================================================================================================================

//! Set - принимает уникальные значения не только из елементов массива но и символов строки new Set(arr) или new Set(str)

// * ==================================================================================================================================

/*
ЗАДАЧА: Есть массив [1,2,3,4,5] развернуть массив не создавая новый массив и не использовать revers
*/

const arr = [1, 2, 3, 4, 5];
let accumStr = "";

for (let i = 0; arr.length; i++) {
  accumStr += arr.pop();
}

for (let i = 0; i < accumStr.length; i++) {
  arr.push(+accumStr[i]);
}

console.log(arr);

// === ==== === === === === === === === === === === === === == === === =

const arr = [1, 2, 3, 4, 5];

for (let i = 0, size = arr.length; i < size; i++) {
  arr.splice(0, 0, arr.splice(i, 1)[0]);
}

console.log(arr);

// * ==================================================================================================================================

//! [].push(10) // => 0 - возвращает индекс запушенного числа
//! {}['a'] = 10 // => 10 - вернет значение
//! arr.a = 10 // => 10 - вернет значение

// * =================================================================================================================================

/*
years = Math.floor(t / (1000 * 60 * 60 * 24 * 30 * 12)),
months = Math.floor(t / (1000 * 60 * 60 * 24 * 30) % 12),
days = Math.floor(t / (1000 * 60 * 60 * 24) % 30),
hours = Math.floor((t / (1000 * 60 * 60)) % 24),
minutes = Math.floor((t / (1000 * 60)) % 60),
seconds = Math.floor((t / 1000) % 60);
*/

// * =================================================================================================================================
/*
### Deep Equal

Напишите функцию, которая будет проверять на “глубокое” равенство 2 входящих параметра

**Inputs**: Any, Any

**Output**: Boolean
*/
// ! Лучшее решение
function deepEqual(a, b) {
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true;
  }

  if (typeof a !== typeof b) {
    return false;
  }

  if (typeof a !== "object" || a === null || b === null) {
    return a === b;
  }

  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }

  for (const key of Object.keys(a)) {
    if (!deepEqual(a[key], b[key])) {
      return false;
    }
  }

  return true;
}

// * ==============================================================================================================================
// ! Мнемоизация (кеширование результата выполнения функции)
/*
    Мемоизация - это сохранение уже вычисленных значений. 
    Когда функция повторно вызывается с теми же аргументами, 
    она должна вернуть готовое значение, не выполняя повторных вычислений. 
    var calc = (function () { var results = {};
*/
function mn(f) {
  const results = {}; // лучше с Map

  return function (arg) {
    if (results[arg]) {
      console.log("Результат из Кэша");
      return results[arg];
    }

    const result = f.call(this, arg);
    results[arg] = result;
    console.log("Закешированно");

    return result;
  };
}

function sum(arg) {
  return arg + arg;
}

const mySum = mn(sum);

console.log(mySum(10)); // Вернуть 10 и закешировать
console.log(mySum(20)); // Вернуть 20 и закешировать
console.log(mySum(20)); // Извлечет из кеша 20

// ! ===============================================================================
/*
* Мемоизация — это метод оптимизации, который ускоряет приложения за счет сохранения результатов дорогостоящих вызовов функций и возвращения кешированного результата для одних и тех же входных данных.
* Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.

*Функции, которые работают с другими функциями, либо принимая их в качестве аргументов, либо возвращая их, называются функциями высшего порядка (higher-order functions).

*Мемоизация нужна только в этих случаях:
    Для дорогостоящих функций, т. е. функций, которые выполняют тяжелые вычисления.
    Для функций с ограниченным и повторяющимся диапазоном входных данных. При этом все возможные значения очень быстро попадают в кэш и функция вообще перестает работать.
    Для рекурсивных функций с повторяющимися входными значениями.
    Для чистых функций, т. е. функций, которые возвращают один и тот же результат  для одних и тех же входных данных
*/

/*
Для того, чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, 
всегда возвращать одни и те же значения в ответ на одни и те же аргументы.

Мемоизация — это компромисс между производительностью и потреблением памяти.
Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.

Может показаться, что собственные реализации мемоизации стоит применять, например, 
при обращениях к неким API из браузерного кода. Однако, делать этого не нужно, 
так как браузер автоматически кэширует их, используя, в частности, HTTP-кэш.

Если вы работаете с React/Redux, можете взглянуть на reselect. 
Тут используется селектор с мемоизацией. Это позволяет выполнять вычисления только в том случае, 
если в соответствующей части дерева состояний произошли изменения.

Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, 
ресурсоёмкие вычисления. 
*/

/*
Важно то, что функция с мемоизацией — это чистая функция. Эта функция, в частности, 
возвращает одно и то же для одних и тех же переданных ей аргументов независимо от того, 
сколько раз до этого её вызывали. Поэтому переменная cache ведёт себя именно так, как ожидаетс
*/

/*
* ЗАМЫКАНИЕ - это некая инкапсулированная область видимости, используемая инициализированной в ней функцией.
* Замыкание — это комбинация функции и ее лексического окружения (окружения, в котором эта функция была объявлена).
* Лексическое окружение в JS - Это просто ссылка на физическое положение переменных в момент написания кода.

* Замыкание — это комбинация функции и лексического окружения, в которой эта функция была объявлена. 

* Слово “лексический” относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. 

* Замыкания — это функции, которые имеют доступ к переменным внешней (замыкающей) функции — цепочке областей видимости даже после того, как внешняя функция вернулась.
*/

function mem() {
  const cache = {};

  return function (arg) {
    if (cache[arg]) {
      console.log("Задействован КЭШ:");
      return cache[arg];
    }

    cache[arg] = arg * 2;
    return arg * 2;
  };
}

const fn = mem();

console.log(fn(2));
console.log(fn(3));
console.log(fn(2));
console.log(fn(4));
console.log(fn(3));
console.log("=======================================================");

function mem2(fn) {
  const cache = {};

  return function (arg) {
    if (cache[arg]) {
      console.log("Задействован КЭШ:");
      return cache[arg];
    }

    cache[arg] = arg * 2;
    return arg * 2;
  };
}

// фибоначи с мемоизацией
function fibonacci(n, memo) {
  memo = memo || {};
  if (memo[n]) {
    return memo[n];
  }
  if (n <= 1) {
    return 1;
  }
  return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo));
}

function memoizer(fn) {
  const cache = {};

  return function (n) {
    if (cache[n]) return cache[n];
    cache[n] = fn(n);
    return cache[n];
  };
}

// простая функция, прибавляющая 10 к переданному ей числу
const add = (n) => n + 10;
add(9);
// аналогичная функция с мемоизацией
const memoizedAdd = () => {
  let cache = {};
  return (n) => {
    if (n in cache) {
      console.log("Fetching from cache");
      return cache[n];
    } else {
      console.log("Calculating result");
      let result = n + 10;
      cache[n] = result;
      return result;
    }
  };
};
// эту функцию возвратит memoizedAdd
const newAdd = memoizedAdd();
console.log(newAdd(9)); // вычислено
console.log(newAdd(9)); // взято из кэша

// простая чистая функция, которая возвращает сумму аргумента и 10
const add = (n) => n + 10;
console.log("Simple call", add(3));
// простая функция, принимающая другую функцию и
// возвращающая её же, но с мемоизацией
const memoize = (fn) => {
  let cache = {};

  return (...args) => {
    let n = args[0]; // тут работаем с единственным аргументом

    if (n in cache) {
      console.log("Fetching from cache");
      return cache[n];
    }

    console.log("Calculating result");
    let result = fn(n);
    cache[n] = result;
    return result;
  };
};
// создание функции с мемоизацией из чистой функции 'add'
const memoizedAdd = memoize(add);
console.log(memoizedAdd(3)); // вычислено
console.log(memoizedAdd(3)); // взято из кэша
console.log(memoizedAdd(4)); // вычислено
console.log(memoizedAdd(4)); // взято из кэша

// *Подобное можно написать самостоятельно, но существуют и библиотечные решения:
// В Lodash имеется функция _.memoize(func, [resolver])
// В ES7 можно воспользоваться декораторами @memoize из decko.

// Для того, чтобы решить эту проблему, рекурсивная функция должна вызывать свой вариант с мемоизацией.
// Вот как можно добавить мемоизацию в рекурсивную функцию вычисления факториала.
// уже знакомая нам функция memoize
const memoize = (fn) => {
  let cache = {};
  return (...args) => {
    let n = args[0];
    if (n in cache) {
      console.log("Fetching from cache", n);
      return cache[n];
    } else {
      console.log("Calculating result", n);
      let result = fn(n);
      cache[n] = result;
      return result;
    }
  };
};
const factorial = memoize((x) => {
  if (x === 0) {
    return 1;
  } else {
    return x * factorial(x - 1);
  }
});
console.log(factorial(5)); // вычислено
console.log(factorial(6)); // вычислено для 6, но для предыдущих значений взято из кэша
// Функция factorial рекурсивно вызывает свою версию с мемоизацией.
// Функция с мемоизацией кэширует результаты вычисления факториала,
// что, при её последующих вызовах, значительно улучшает производительность.
// То есть, в вышеприведённом примере оказывается, что вместо перемножения чисел от 1 до 6 для нахождения факториала числа 6,
// на 6 придётся умножить лишь то, что было возвращено предыдущим вызовом factorial(5).
// * ==============================================================================================================================
function fizzbuzz(number) {
  return number % 3 === 0 && number % 5 === 0 ? "FizzBuzz" : number % 3 === 0 ? "Fizz" : number % 5 === 0 ? "Buzz" : number;
}
/*
! Почему то при получении 0 при проценте от деления 15 % 3 Числовой НОЛЬ и Еденица не преобразуется в с мопомщью неявного преобразования ! в булевое значение. Только явным преобразованием возможно преобразовать
* !15 % 5 // все равно будет число 0
* !!15 % 5 // будет 1
* Boolean(15 % 5); // И только так false
* !Boolean(15 % 5); // И только так true
*/

// * ==============================================================================================================================
//! Если пустой массив привести к числу будет 0, если же в массиве есть одно значение, то будет 1, а если в массиве больше одного значения то будет NaN

// * =================================================================================================================================

/*
Реализуйте функцию merge, которая будет принимать неограниченное количество объектов в качестве аргументов и возвращать новый объект, 
который должен содержать все поля со всех объектов. 
Если ключи в объектах повторяются, то каждый последующий объект при совпадении ключей должен иметь больший приоритет над предыдущим. 
Порядок полей в результирующем объекте не важен.
*/
const merge = (...collections) => {
  return collections.reduce((obj, el) => {
    for (key in el) obj[key] = el[key];
    return obj;
  }, {});
};

console.log(
  merge(
    {
      name: "John",
      age: 22,
    },
    {
      surname: "Klein",
      age: 20,
      profession: "student",
    },
    {
      profession: "frontend developer",
      country: "USA",
    }
  )
);

// {
//   name: 'John',
//   surname: 'Klein',
//   age: 20,
//   profession: 'frontend developer',
//   country: 'USA',
// }

const merge2 = (...collections) => {
  return { ...Object.assign(...collections) };
};

console.log(
  merge2(
    {
      name: "John",
      age: 22,
    },
    {
      surname: "Klein",
      age: 20,
      profession: "student",
    },
    {
      profession: "frontend developer",
      country: "USA",
    }
  )
);

// {
//   name: 'John',
//   surname: 'Klein',
//   age: 20,
//   profession: 'frontend developer',
//   country: 'USA',
// }

// * ========================================================================================================================
//! Функция которая возвращает класс объекта
function showClass(object) {
  return Object.prototype.toString.call(object).slice(8, -1);
}

console.log(showClass("")); // String
console.log(showClass(true)); // Boolen
console.log(showClass(null)); // Null  //! - покажет верно в отличии от typeof // object
// * ==========================================================================================================================
/*
!Для того, чтобы понять как в JavaScript  работает строгое сравнение (===), нужно знать несколько базовых для него (языка) концепций:
  
1) В JavaScript нет переменных, а есть только идентификаторы, которые содержат в 
себе ссылку на данные. То есть когда Вы пишите например:
  var ident1 = 10;
  var ident2 = { name: ‘someName’ };
  var ident3 = ’some string’;
  
То ident1 , ident2 , ident3 содержат в себе ссылки на структуры описывающие 
данные. То есть, вопреки тому, что Вам рассказывают ident1 и ident3 не содержит 
сами данные, но так же как и  ident2 , содержат ссылку на структуру данных.
  
2) Данные в JS иммутабельные.  То есть неизменны. На языке спецификаций данные - 
это реальные физические байты информации, которые обозначают термином термином 
Primitive Value_
  
То есть объявив строку, средствами языка вы не можете ее изменить. Изменения 
исходной строки (или любых других Primitive Value), приводят к созданию новой. 
Следствием этого является тот факт, что когда Вы пишите например: 
  var str1=”my string”;
  var str2=”my string”;
  
то идентификатор str1 и str2 содержит в себе одну и туже ссылку на одни и те же 
данные.  То есть RunTime не создает две структуры данных с одной и той же 
строкой. То есть RunTime строго следит за тем, чтобы те Primitive Value которые 
уже описаны, и заявляются снова в нашем коде, получали ту же самую ссылку.
  
3) Строгое сравнение в JS (===) сравнивает только ссылки из идентификаторов. 
Никакого сравнения типов и прочей чепухи о которой Вам рассказывают - нет. 
Потому, что это не нужно учитывая все 3 пункта. 
Например:
  var myNum=3;
  var myEnotherNum=3;
  myNum === myEnotherNum;  
    // true Потому что оба идентификатора содержат одну и туже ссылку на структуру  описывающую Primitive Value: 3.
  
или 
  var myObj = { name: ‘someName’ };
  var myObj2 = myObj;
  var myEnotherObj2 = { name: ‘someName’ };
  myObj === myObj2; // true
  myObj === myEnotherObj2; // false
  myObj['name'] === myEnotherObj2['name']; // true
*/

/*
!Специальное значение NaN и забавный факт о нем
Люди, которые обладают достаточной квалификацией для того, чтобы учить других 
людей знают, что NaN это состояние числа с плавающей точкой, спецификация 
которого описана стандартом IEEE 754. 
  
Стандарт IEEE 754 это стандарт описывающий: структуру, математику, пограничные 
случаи - словом все что нужно для реализации работы с подобными числами.  Этому 
стандарту следуют практически все современные языки программирования. 
  
Согласно этой спецификации, NaN это число которое не равно ни одному другому 
числу, в том числе и самому себе. 
  
Существование подобной конструкции, обусловлено тем, что существуют ситуации, 
когда результат, в силу обстоятельств, не может быть вычислен, но при этом он 
должен всегда оставаться числом. Самый простой пример зачем это нужно - работа 
алгоритмов оптимизации, которые опираются на тип данных с которыми они работают.
  
По этой причине, ни при каких условиях, конструкция NaN === NaN не может быть true 
и всегда будет false 
  
По же причине, абсолютно безграмотно  писать код в котором сравнение конструкций 
содержащих NaN может быть эквивалентно друг другу.  Это ровно тоже самое, что 
требовать чтобы 2 x 2 равнялось не только 4 но и любому другому числу.
*/

/*
!Проверить на тип
Унарный оператор typeof, несмотря на то как он звучит, не проверяет тип данных 
или структур данных. Унарный оператор typeof возвращает строку, в соответствии с 
определенными критериями, которые совсем не обязательно зависят от типа 
оперируемых идентификаторов. И может быть абсолютно любым, в том числе и теми 
какими Вы сами захотите.

При использовании строго сравнения в JS нет никакой необходимости в проверке 
типа данных, по причине описанной выше в Deep Equal.
*/

/*
!О самой задаче по проверки эквивалентности обьектов
Если в Вашей практике возникла ситуация, когда Вам нужно сравнивать 
эквивалентность двух структур данных, то это первый признак просчетов в 
архитектуре Вашего кода. То есть в такой ситуации, нужно искать не способы такую 
эквивалентность установить, но искать проблемы в коде с целью приведения его 
архитектуры к состоянию, где подобная проверка не требуется. 
  
Если вынести это за скобки, и предположить, что операция установления 
эквивалентности двух структур данных оправдана, то подобная задача должна 
решаться либо на уровне отслеживания прототипов структур данных как минимум, или 
на уровне хеширования данных структуры и сравнения уже хешей как максимум. Но не 
способами заявленными в видео.
*/

/*
!Что вообще делает функция Bind?
Функция bind не привязывает контекст.  this - в JavaScript это не контекст. И не 
может быть контекстом. В JavaScript не существует ни одного прямого способа 
управления контекстом исполнения кода. 
 
! this это обычный идентификатор, который указывает на данные в зависимости от 
условий выполнения кода. 
 
Например для случая, когда функция вызывается как метод объекта:
myObj.myMethod()

то RunTime по умолчанию установит this на тот обьект myObj. 
Если та же функция будет вызвана не как метод объекта, например: 
var func=myObj.myMethod; 
func();

то this, по умолчанию, будет указывать на 
глобальную область видимости или на undefined. 
И это поведение, сам программист может легко менять. 

По этим причинам - совершенно неправильно и безграмотно в JavaScript называть 
this контекстом. Что подтверждает и официальная спецификация ECMA.
  
Соответственно, call и apply  не привязывают контекст функции. 
Но позволяют определить значение идентификатора this.
*/

/*
!Никогда, не при каких обстоятельствах не трогайте свойство prototype у native функций, 
которые вызываются как конструкторы. Тем самым вы разрушите всю работу, которую 
делает RunTime по оптимизации процессов связанных с объектами, которые созданы 
благодаря этому конструктору. 
  
То есть Ваш код будет работать, но производительность вашего кода будет на самом 
низком уровне. И что хуже всего, это затронет любой код связанный с этим 
конструктором.
*/

/*
! Объявление функции создает свой новый контекст
Это правда. Только этот контекст не имеет ничего общего с this. 
this не будет указывать на контекст этой или любой другой функции. 
  
В этой части, автор видео полностью запутался, перемешав между собой два 
совершенно независимых друг от друга механизма: установка идентификатора this 
для случая, когда он не определен другими способами, и установки execution 
context, на который прямо мы влиять в JavaScript не можем. Но можем косвенно.

Очевидно что автор видео, постоянно ошибочно называет this контекстом. 
То есть в данном случае он хотел сказать, что при вызове стрелочной функции, не 
задано поведение по умолчанию, для определения значения идентификатора this. 

В следствии чего, при вызове стрелочной функции, this останется 
нетронутым и будет указывает на то значение, которое было прописано в 
идентификаторе который лежит в Lexical Environment.  

Говоря простым языком - this всегда будет указывать на то значение, на 
которое указывает то this, которое было зафиксировано на момент 
определения стрелочной функции.
*/

/*
!Потому, что let или const ничем не отличаются от var кроме дополнительных издержек для осуществления работы логики контроля блочной области видимости. 
Мне блочная область видимости, ценой производительности не нужна, потому я использую var и буду использовать дальше. 
Если бы использование Let и Const ничего не стоило в сравнении с var то использовал для красоты их. А так я все время нервничаю, когда какой либо синтаксис заставляет меня терять дополнительные милллисекунды на ровном месте.

! блочная область видимости у let и const обходится более низкой производительностью кода.
! то есть код использующий let и const будет медленне чем код написанный с использование var

Используя Let или Const очень легко написать код, который
никогда не получит оптимизированного кода
Например использование const в лексическом окружении,  с вложенностью глубже одного 
(функция 1, вызывает функцию 2, которая вызывает функцию 3, где и использует идентификатор)  

Таковы ограничения современного TurboFan, который может эффективно оптимизировать 
const не глубже одного уровня вложенности. В отличии от var.
*/

// * ========================================================================================================================
//!!!! Контекст (this) в JS
// Примечание: под "точкой" в тексте подразумевается вызов как метод объекта, т.е. либо obj.fn(), либо obj['fn']()

// Глобальным контекстом функций является Window при отсутствии "use strict" и undefined при его наличии

// 1. this в классах и функциях-конструкторах
// Является экземпляром класса, который вы создаете с помощью new, и устанавливается в момент создания этого экземпляра

// ```js
// class Test {
//   constructor(name) {
//     // this = объекту, который мы создаем после объявления класса.
//     // Устанавливается в момент вызова new
//     this.name = name;
//   }
// }

// const test = new Test('Имя, которое установится в поле name созданного объекта')
// // Объект, который записался в test, во время создания
// // экземпляра был в this класса Test, поэтому мы смогли установить его поле name
// ```
// 2. this в обычных функциях
// Контекст обычной функции устанавливается в момент вызова функции. Это называется "поздним связыванием".

// Если при вызове слева от названия функции нет точки, то контекстом функции является глобальный контекст (undefined в strict моде и window без него). Если же при вызове функции слева от её названия есть точка, то контекстом функции будет являться объект, находящийся слева от точки.

// obj /* <-- контекст функции*/
//   .fn();
// fn(); // контекст равен глобальному контексту (undefined в strict моде и window без него)
// [1] Если метод присвоить в переменную, а затем функцию вызвать из этой переменной, контекст будет потерян, потому что слева от точки при вызове ничего не будет

// const obj = {
//     fn() {
//         console.log(this)
//     },
// };
// obj.fn(); // obj

// const fn = obj.fn;
// fn() // глобальный контекст (undefined в strict моде и window без него)
// [2] Если обычную функцию, при вызове которой контекст был равен глобальному контексту, присвоить в объект, а затем вызвать эту функцию как метод объекта, контекстом функции станет этот объект, потому что слева от точки при вызове функции будет расположен этот объект

// function fn() {
//     console.log(this);
// }

// fn(); // глобальный контекст (undefined в strict моде и window без него)

// const obj = {};
// obj.fn = fn;

// obj.fn(); // obj
// [3] Если передать ссылку на метод в функцию и вызвать его внутри неё, то он будет вызван как обычная функция, а не как метод объекта, поэтому его контекст будет утерян.

// const someFn = (callback) => {
//  callback(); // любая функция/метод, переданная сюда, будет вызвана без точки слева,
//  // т.е. не от имени объекта. Это означает, что её контекст будет утерян
// };

// const obj = {
//  method: function() {
//   console.log(this);
//  },
// };

// someFn(obj.method) // this будет равен undefined при use strict и window без него
// Тем не менее мы можем избежать такого поведения, обернув вызов нашего метода в обычную или стрелочную функцию:

// const someFn = (callback) => {
//  callback();
//  /*
//   Контекст все равно будет утерян, но утерян он будет у переданной функции,
//   т.е. у нашей функции-обертки

//   Вызов же метода в этой функции-обертке все равно делается через точку,
//   т.е. от имени объекта.

//   Благодаря этому, мы избегаем потери контекста
//  */
// };

// const obj = {
//     method: function() {
//         console.log(this);
//     },
// };

// someFn(() => obj.method()); // this в методе будет равен obj
// someFn(function() { obj.method() }); // this в методе будет равен obj
// 3. this в стрелочных функциях
// Контекст стрелочной функции устанавливается в момент объявления функции. Это называется "ранним связыванием". Это также означает то, что bind/apply/call не дадут никакого результата при вызове на стрелочной функции.

// const fn = () => console.log(this); // this должен быть глобальным контекстом
// // (undefined в strict моде и window без него)
// fn.call({
//   name: 'новый контекст',
// }); /* Вызов через call должен принудительно привязать
//  новый контекст к функции, но тем не менее this все равно равен глобальному контексту
//  (undefined в strict моде и window без него) */
// Стрелочная функция не создает собственный контекст, она берет его из внешнего лексического окружения:

// [1] Если вы объявляете стрелочную функцию в глобальном контексте (не внутри функций/методов, но при этом сама стрелочная функция может быть методом), то контекстом этой стрелочной функции является глобальный контекст (undefined в strict моде и window без него)

// const fn = () => console.log(this);
// const obj = {
//   fn: () => console.log(this) /* контекст создают только функции,
//    поэтому даже если стрелочная функция сама является
//    методом объекта (не обернутого в функцию),
//    контекстом для этой функции будет глобальный контекст
//    (undefined в strict моде и window без него) */,
// };

// fn(); // глобальный контекст (undefined в strict моде и window без него)
// obj.fn(); // глобальный контекст (undefined в strict моде и window без него)
// [2] Если вы объявляете стрелочную функцию внутри другой функции/метода, то контекстом этой стрелочной функции будет контекст функции/метода, в котором эта стрелочная функция объявлена.

// const obj = {
//   fn() {
//     /* <-- стрелочная функция возьмет контекст этой функции,
//       // а он равен obj, если вызывать ее через obj */
//     const arrowFn = () => console.log(this);
//     arrowFn();
//   },
// };

// obj.fn(); // obj
// [3] Исходя из пункта [1] и [2] можно сделать следующий совмещенный пример, чтобы глубже понять, как это работает:

// const obj = {
//   // <-- контекст метода fn будет равен obj1,
//   // если вызвать этот метод через точку (obj1.fn())
//   fn1() {
//     // <-- контекст стрелочной функции будет определен этой функцией,
//     // т.к. она является ближайшей для него функцией
//     return {
//       fn2: () => {
//         // функция возьмет контекст ближайшей внешней функции
//         console.log(this);
//       },
//     };
//   },
// };

// obj.fn1().fn2(); // this стрелочной функции = obj. fn1 возвращает внутренний объект,
// // на котором вызывается метод fn2. Метод fn2 берет контекст ближайшей к нему функции -
// // fn1, а та, в свою очередь, вызвана как метод объекта,
// // значит ее контекстом и контекстом стрелочной функции будет obj
// 4. this в обработчиках событий addEventListener
// Это редкий случай, но учтите, что this будет ссылаться на DOM элемент, на который вешали обработчик.

// * ================================================
// !Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.
// !Декоратор - это это функции обертки, которые принимают какую то функцию и могут расширять ее функционал. На выходе возвращая новую функцию которую мы можем использовать (с увеличеным функционалом).
/*
Prototypes Decorator
Необходимо добавить возможность логирования в функцию add класса Addition

Используя прототип класса Addition добавить декоратор к функции add, дающий возможность логировать ее вызов
При этом результат выполнения add должен быть как и в оригинале, но дополнительно при вызове выводить в консоль 'called'

Менять изначальную функцию, класс или созданный объект нельзя.
Код можно писать только в обозначенной зоне.

Пример:
const startedValue = new Addition(5);
const result = startedValue.add(3,5,6) //В консоль выводится "called"
console.log(result) //В консоль выводится 19
*/

class Addition {
  constructor(num) {
    this.num = num;
  }

  add(...nums) {
    const sum = (a, b) => a + b;
    return this.num + nums.reduce(sum);
  }
}

function deck(f) {
  return function (...nums) {
    console.log("called");
    return f.bind(this)(...nums);
  };
}

Addition.prototype.add = deck(Addition.prototype.add);

// Пример:
const startedValue = new Addition(5);
const result = startedValue.add(3, 5, 6); //В консоль выводится "called"
console.log(result); //В консоль выводится 19

const startedValue2 = new Addition(5);
const result2 = startedValue.add(3, 5, 6, 10); //В консоль выводится "called"
console.log(result2); //В консоль выводится 29
// * =======================================================================================================
const newObj = Object.create(
  {},
  {
    name: {
      value: "Ruslan",
      enumerable: true,
      writable: true,
    },

    age: {
      value: 36,
      enumerable: true,
    },

    text: {
      value:
        "Мы не сможем это свойство итерировать, перезаписать или удалить из-за дискриптеров, подефолту находящитхся в false (enumerable: false, writable: false ....)",
    },

    sayName: {
      letter: ".....",

      get() {
        return this.name;
      },

      set(arg) {
        this.name = arg;
      },
    },
  }
);

console.log(Object.keys(newObj)); // ['name', 'age']
console.log(newObj.text); // "Мы не сможем это свойство итерировать, перезаписать или удалить из-за дискриптеров, подефолту находящитхся в false (enumerable: false, writable: false ....)
console.log(newObj.sayName); // Ruslan
newObj.sayName = "Sultan";
console.log(newObj.sayName); // Sultan
newObj.name = "Toma";
console.log(newObj.sayName); // Toma

// * ================================================================================================================================================
//!JS - Не обеспечивает порядок выполнения записанный в коде!
function first() {
  console.log(1);
}

function second() {
  console.log(2);
}

first(); //! если код в функции будет громоздкий, то сначала выполнится код из функции second
second();

// ! По сути вызов функции в браузере в рамках одного лексического окружения асинхронен.
// ! callback функция это функция переданная в качестве аргумента другой функции
// * ============================================================================================================================
// * ============================================================================================================================
// ! Интерфейс - ЭТО СПОСОБ ВЗАИМОДЕЙСТВИЯ
// * ============================================================================================================================
// * ============================================================================================================================
// ! API - application programming interface (описание способов, которыми одна компьютерная программа может взаимодействовать с другой программой)
// * ============================================================================================================================
// ! REST (representation state transfer) архитектурный стиль взаимодействия компонентов распределенного приложения в сети
// * ============================================================================================================================
// ! Cookie  - Механизм сохранения данных на клиенте (может хранить состояние клиента)
// ! протокол — это правила, по которым происходит общение.
// * ============================================================================================================================
// XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.
//! Аутентификация – это процесс обмена учетными данными для идентификации пользователя.
// !При аутентификации на основе cookies уникальный идентификатор (файл cookie) создается на стороне сервера и отправляется в браузер.
