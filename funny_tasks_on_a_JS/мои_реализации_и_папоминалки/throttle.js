/*
Throttle
Реализуйте функции throttle.

Примечание: из-за особенностей тестирования реализация new Date() изменена так, что изначальная текущая дата (new Date() или Date.now()) будет равна нулю и будут вручную увеличиваться в тестах. Учтите это, если будете использовать дату в реализации функций.

Примечание: функции, полученные из throttle, должны передавать полученные аргументы и контекст вызова в оригинальную функцию

Примечание: функция throttle может быть реализована без использования таймеров

Функция должна принимать функцию и время задержки, а возвращать модифицированную функцию. Возвращенная функция должна следовать следующим правилам:

Функция throttle должна вызывать функцию и запускать таймер, равный времени задержки, в течение которого функция не может быть вызвана заново. Throttle необходим для того, чтобы обеспечить возможность вызова функции не чаще, чем указанное время задержки. Если время задержки равно 500 мс, то при вызове функции, возвращенной из throttle, каждые 100 мс 10 раз подряд функция будет вызвана лишь три раза:
первый вызов функции на 0мс (первая попытка вызова функции после 0 мс задержки),
второй на 500 мс (пятая попытка вызова функции после 500 мс задержки)
и третий на 1000 мс (десятая попытка вызова функции после 1000 мс задержки).
*/
const throttle = (fn, throttleTime) => {
  let bull = true;

  return function () {
    if (bull) {
      fn.call(this, ...arguments);
      bull = false;
      setTimeout(() => (bull = true), throttleTime);
    }
  };
};

let counter = 0;
const fn = () => {
  counter++;
};

const throttledFn = throttle(fn, 500); // функция может быть вызвана не чаще, чем раз в 500 мс
const intervalId = setInterval(throttledFn, 100);
setTimeout(() => clearInterval(intervalId), 1000); // удаляем интервал через 10 вызовов

setTimeout(() => console.log(counter), 1000); // 2
// * ===========================================================================================
function debounce(f, ms) {
  let detect = true;

  return function (str) {
    if (detect) {
      f(str);
      // f.call(this, str); // * если вдруг потребуется сохранить контекст вызова
      detect = false;
      setTimeout(() => (detect = true), ms);
    }
  };
}

let debounceFunc = debounce(console.log, 1000);
// выполняется немедленно
debounceFunc("MockInterview 1");
// ничего не выполнится, так как не прошло еще 1000 ms с последнего выполнения
debounceFunc("MockInterview 2");
// ничего не выполнится, так как не прошло еще 1000 ms с последнего выполнения
setTimeout(() => debounceFunc("MockInterview 500"), 500);
// Выполнится
setTimeout(() => debounceFunc("MockInterview 1200"), 1200);
// ничего не выполнится, так как не прошло еще 1000 ms с последнего выполнения
setTimeout(() => debounceFunc("MockInterview 1500"), 1500);
// выполнится
setTimeout(() => debounceFunc("MockInterview 2210"), 2210);
// * ===============================================================================================
