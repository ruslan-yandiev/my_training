/*
Задание с https://learn.javascript.ru/

Создайте декоратор spy(func), который должен возвращать обёртку,
которая сохраняет все вызовы функции в своём свойстве calls.
Каждый вызов должен сохраняться как массив аргументов.
*/
//! Декоратор-шпион
function spy(func) {
    function w(...args) {
        func.apply(this, args); // или передать песевдо массив из ES5 arguments вместо args-не является зарезервированным
        w.calls.push(args);
        return func;
    }

    // ! вариант без привязки контекста
    // function w(...args) {
    //     w.calls.push(args);
    //     return func(...args);
    // }

    w.calls = [];
    return w;
}

function work(a, b) {
    console.log(a + b);
}

work = spy(work);

work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
    console.log('call:' + args.join()); // "call:1,2", "call:4,5"
}

// P.S.: Этот декоратор иногда полезен для юнит-тестирования. Его расширенная форма – sinon.spy – содержится в библиотеке Sinon.JS.
// ==========================================================================

/*
*Декоратор, специальная функция, которая принимает другую функцию и изменяет её поведение.

Идея состоит в том, что мы можем вызвать cachingDecorator с любой функцией, 
в результате чего мы получим кеширующую обёртку. Это здорово, 
т.к. у нас может быть множество функций, использующих такую функциональность, 
и всё, что нам нужно сделать – это применить к ним cachingDecorator.

Отделяя кеширующий код от основного кода, мы также сохраняем чистоту и простоту последнего.
*/

// !Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.

/*
*Мемоизация - это сохранение результатов вызова функции для того чтобы в следующий раз не выполнять вычисления при одинаковых аргументах.
*Декоратор - это уже шаблон проектирования, который, как ты и написал, добавляет поведение функции.
Мемоизация не обязательно должна реализоваться с помощью декоратора. Например это может быть просто функция, которая делает проверки и сохраняет результат, если такого еще не было. Сохранение результатов может быть и в глобальную переменную и в свойство объекта, а может быть и во внешний скоуп внешней функции (при замыкании), то есть мемоизация может быть реализована как угодно, не обязательно в виде декоратоа:

Функция с мемоизацией, без декоратора:
const memoRepo = {};
const memo = (a) => {
  if (a in memoRepo) {
    return memoRepo[a];
  }
  memoRepo[a] = a + 1;
  return memoRepo[a];
};
memo(1);
memo(1); // значение возьмется из memoRepo
memo(2);
*/

function hash() {
    // ! Этот трюк называется заимствование метода.
    alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);

// ==========================================================================
/*
Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд. Например:
Другими словами, delay(f, ms) возвращает вариант f с «задержкой на ms мс».

В приведённом выше коде f – функция с одним аргументом, но ваше решение должно передавать все аргументы и контекст this.

Открыть песочницу с тестами для
*/

//! Задерживающий декоратор
function delay(f, ms) {
    return function(...args) {
        setTimeout(()=>  f.apply(this, args), ms);
    }

    // ! вариант два
    // return function() {
    //     setTimeout(()=>  f.apply(this, arguments), ms);
    // }
}

function f(x) {
    alert(x);
}

// создаём обёртки
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000("test"); // показывает "test" после 1000 мс
f1500("test2"); // показывает "test" после 1500 мс

/*
Обратите внимание, как здесь используется функция-стрелка. Как мы знаем, функция-стрелка не имеет собственных this и arguments, поэтому f.apply(this, arguments) берет this и arguments из обёртки.

Если мы передадим обычную функцию, setTimeout вызовет её без аргументов и с this=window (при условии, что код выполняется в браузере).

Мы всё ещё можем передать правильный this, используя промежуточную переменную, но это немного громоздко:

function delay(f, ms) {

  return function(...args) {
    let savedThis = this; // сохраняем this в промежуточную переменную
    setTimeout(function() {
      f.apply(savedThis, args); // используем её
    }, ms);
  };

}
*/
