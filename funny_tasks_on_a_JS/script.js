/*
Результатом декоратора debounce(f, ms) должна быть обёртка, 
которая передаёт вызов f не более одного раза в ms миллисекунд. 
Другими словами, когда мы вызываем debounce, 
это гарантирует, что все остальные вызовы будут игнорироваться в течение ms.

На практике debounce полезен для функций, которые получают/обновляют данные, 
и мы знаем, что повторный вызов в течение короткого промежутка времени не даст ничего нового. 
Так что лучше не тратить на него ресурсы.
*/
// function debounce(f, ms) {
//   let detect = true;

//   return function (arg) {
//     if (detect) {
//       f(arg);
//       detect = false;
//     }

//     setTimeout(() => (detect = true), ms);
//   };
// }

// let f = debounce(console.log, 1000);

// f(1); // выполняется немедленно
// f(2); // проигнорирован

// setTimeout(() => f(3), 100); // проигнорирован (прошло только 100 мс)
// setTimeout(() => f(4), 1100); // выполняется
// setTimeout(() => f(5), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
// setTimeout(() => f(6), 2300); // выполняется

//* =======================================================================================================================
/*
Даны две строки.
Написать функцию, которая вернёт True, если из первой строки можно получить вторую, совершив не более 1 изменения 
(== удаление / замена символа).
*/

//! собес #4
const obj = {};
const obj2 = Object.create;
const obj3 = Object.create(null);
const obj4 = new Object();
console.log(obj2.__proto__ === Object.__proto__); //! true     ƒ () { [native code] } === ƒ () { [native code] }
// ! Мы не можем вывести код JS функции в консоль, потому что функции являются частью скомпилированного исполняемого файла браузера ... или, скорее, его движка JavaScript. Это нативный код.
console.log(Object.__proto__); // ƒ () { [native code] } //! базовая конструкция функции в доичном коде, нет смысла отображать двочиный код во и пишет ƒ () { [native code] }
console.log(obj3.__proto__ === Object.__proto__); // false
console.log(obj3.__proto__); // undefined
console.log(Object.prototype.__proto__); // null
