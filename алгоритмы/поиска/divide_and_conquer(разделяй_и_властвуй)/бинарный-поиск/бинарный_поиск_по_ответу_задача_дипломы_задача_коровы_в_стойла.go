package main

import (
	"fmt"
)

// ! Бинарный поиск по ответу - название техники бинарного поиска
// *-Пусть отвеь на задачу изменяется монотонно
// 	   *("ответ Х не подходит, значит все ответы < X не подходят; ответ Х подходит, значит все ответы > X подходят", либо наоборот).
// *-Пусть можно также эффективно проверить, подходит ответ Х или нет.
// *-Если вышеуказанные два условия подходят, тогда при помощи бинарного поиска мы можем эффективно подбирать минимальный или максимольный подходящий ответ

// задача "Дипломы"
// есть N дипломов размера (H x W)
// все дипломы нужно повесить на квадратной доске размера (S x S). Дипломы нельзя поворачивать
// Требуется определить минимальный размер стороны доски S, позволяющий разместить все дипломы.
func can(diplomCount, diplomHeight, diplomWidth, boardSize int) bool {
	// вычислим сколько строк и столбцов дипломов мы сможем уместить на доске
	rows := boardSize / diplomHeight
	colums := boardSize / diplomWidth

	// получаем общее количество дипломов умещающихся на доске
	return colums > 0 && rows >= (diplomCount+colums-1)/colums //rows*colums >= diplomCount упрощенный способ с умножением может быть переполнен
}

func findingD(n, h, w int) int {
	// поставим указатели l и r на заведомо не подходящее и подходящее число
	l := 0
	r := n * h

	var m int

	// выполняем двоичный поиск до двух элементов
	for l+1 < r {
		m = l + (r-l)/2 // упрощенный варинт будет (l+r)/2 но он опасен переполнением из-за больших цифр при сложении

		if can(n, h, w, m) {
			r = m
		} else {
			l = m
		}
	}

	// l и r формируют границу так называемой границы водораздела, где l будет указывать на неправильное число, а r на верное
	return r
}

// ! поскольку временная сложность функции can является константной O(1), то общая сложность решения определяется бинарным поиском Асимпатическая оценка O(log n)
func main() {
	fmt.Println(findingD(13, 5, 3)) // 15
}

// =====================================================================================================================================
/*
На прямой расположены N стойл(координаты стойл известны)
В стойлах нужно разместить M коров. Каждая корова занимает одно стойло,
коровы должны распологаться как можно дальше друг от друга.
Требуется определить максимально возможное растоение между ближпйшими коровами
*/

func main() {
	fmt.Println(findingD(13, 5, 3))
}
