//! Два указание - это название нескольких способов оптимизации решений, содержащих вложенные циклы.
//! Оптимизация происходит за счет того, что во внутреннем цикле инекс движется только в одном направлении и не возвращается назат

// * два указателя вариант 1 движутся в одну сторону
// * 1) убрать дубли в отсортированном массиве 2) нати максимальный/минимальный "хороший" участок 2) найти количество "хороших" участков и подобное
// удалить дубликаты в отсортированном массиве и вернуть в том же порядке, без использования дополнительной памяти. Сложность O(n)
func deleteD(arr []int) []int {
	first, second := 0, 0

	for second < len(arr) {
		if second < len(arr)-1 && arr[second] == arr[second+1] {
			second++
		} else {
			arr[first] = arr[second]
			first++
			second++
		}
	}

	return arr[:first]
}

func main() {
	fmt.Println(deleteD([]int{1, 1, 2}))                            // [1, 2]
	fmt.Println(deleteD([]int{1, 1, 1, 1, 2, 3, 3, 3, 4, 4, 5, 6})) // [1, 2, 3, 4, 5, 6]
}

// ========================================
func deleteD(arr []int) []int {
	first, last := 0, 0

	for last < len(arr) {
		if arr[last] == arr[first] {
			last++
		} else {
			arr[first+1] = arr[last]
			first++
			last++
		}
	}

	return arr[:first+1]
}

func main() {
	fmt.Println(deleteD([]int{1, 1, 2}))                            // [1, 2]
	fmt.Println(deleteD([]int{1, 1, 1, 1, 2, 3, 3, 3, 4, 4, 5, 6})) // [1, 2, 3, 4, 5, 6]
}

// ===========================================
func foo(arr []int) []int {
	index := 1
	for l, r := 0, 0; r < len(arr); r++ {
		if arr[l] != arr[r] {
			l++
			index++
			arr[l] = arr[r]
		}
	}

	return arr[:index]
}

func main() {
	arr := []int{2, 3, 4, 4, 4, 5, 5, 5, 6, 6, 8, 8, 8, 11, 14, 14, 14, 33}

	fmt.Println(foo(arr))
}

//============================================
/*
Когда у Валеры появляется свободное время, он идет в библиотеку и читает книги. Вот и сегодня у него появилось t свободных минут для чтения. Поэтому Валера взял n книг в библиотеке и для каждой книги оценил: какое время потребуется, чтобы ее прочитать. Пронумеруем книги целыми числами от 1 до n. Для прочтения i-той книги Валере требуется ai минут.

Валера решил, что он выберет произвольную книгу с номером i и будет читать книги друг за другом, начиная с этой книги. Другими словами, сначала он прочитает книгу c номером i, затем книгу с номером i + 1, затем книгу с номером i + 2 и так далее. Он продолжает этот процесс до тех пор, пока либо не закончится его свободное время, либо не прочитает книгу с номером n. Каждую книгу Валера читает целиком, то есть он не читает книгу, которую не успеет дочитать до конца из-за нехватки свободного времени.

Посчитайте максимальное количество книг, которое Валера сможет прочитать.

Входные данные
В первой строке заданы два целых числа n и t (1 ≤ n ≤ 105; 1 ≤ t ≤ 109) — количество книг и количество свободных минут у Валеры соответственно. Во второй строке задана последовательность из n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 104), в которой число ai обозначает количество минут, которое требуется для прочтения i-ой книги.

Выходные данные
Выведите единственное целое число — максимальное количество книг, которое Валера сможет прочитать.
*/
func foo(n, t int, timeCollection []int) int {
	l, r, sum, maxLen := 0, 0, 0, 0

	for r < n {
		sum += timeCollection[r]

		for sum > t {
			sum -= timeCollection[l]
			l++
		}

		r++

		if maxLen < r-l {
			maxLen = r - l
		}
	}

	return maxLen
}

// --------
func foo(n, t int, timeCollection []int) int {
	sum, maxLen := 0, 0

	for l, r := 0, 0; r < n; r++ {
		sum += timeCollection[r]

		for ; sum > t; l++ {
			sum -= timeCollection[l]
		}

		if maxLen < r-l+1 {
			maxLen = r - l + 1
		}
	}

	return maxLen
}

func main() {
	fmt.Println(foo(4, 5, []int{3, 1, 2, 1}))                    // 3 - книги
	fmt.Println(foo(3, 3, []int{2, 2, 3}))                       // 1 - книга
	fmt.Println(foo(10, 5, []int{1, 2, 2, 3, 3, 1, 1, 2, 1, 5})) // 4 - книги
	fmt.Println(foo(6, 5, []int{5, 10, 10, 1, 1, 1}))            // 4 - книги
}

// ============================================================================================================================================
/*
На прекрасном побережье Адриатического моря расположено N отелей. Стоимость каждого отеля указана в евро.

Срольо выиграл M евро в лотерею. Теперь он хочет купить последовательность последовательных отелей, чтобы сумма значений этих последовательных отелей была как можно больше, но не больше M.

Вам необходимо рассчитать это максимально возможное общее значение.

Входные данные
В первой строке входных данных указаны целые числа N и M (1 ≤ N ≤ 300 000, 1 ≤ M < 231).

В следующей строке указано N натуральных чисел меньше 106, представляющих значения отелей в том порядке, в котором они расположены вдоль побережья.

Вывод
Выведите требуемое число (оно будет больше 0 во всех тестовых данных).
*/

func foo(n, m int, arr []int) int {
	sum, result := 0, 0

	for l, r := 0, 0; r < n; r++ {

		sum += arr[r]

		for sum > m {
			sum -= arr[l]
			l++
		}

		if result < sum {
			result = sum
		}
	}

	return result
}

func main() {
	fmt.Println(foo(5, 12, []int{2, 1, 3, 4, 5})) // 12
	fmt.Println(foo(4, 9, []int{7, 3, 5, 6}))     // 8
}

// ===============================================================================================================================================
/*
Учитывая массив из n натуральных чисел, ваша задача - подсчитать количество подмассивов, имеющих сумму x.
Входные данные
Первая строка ввода содержит два целых числа n и x: размер массива и целевую сумму x.
Следующая строка содержит n целые числа a_1,a_2,\dots,a_n: содержимое массива.
Вывод
Выведите одно целое число: требуемое количество подмассивов.
Ограничения

1 \le n \le 2 \cdot 10^5
1 \le x,a_i \le 10^9
*/
func foo(n, m int, arr []int) int {
	sum, result := 0, 0

	for l, r := 0, 0; r < n; r++ {
		sum += arr[r]

		for sum > m {
			sum -= arr[l]
			l++
		}

		if sum == m {
			result++
		}
	}

	return result
}

func main() {
	fmt.Println(foo(5, 7, []int{2, 4, 1, 2, 7})) // 3
}

// ======================================================================================================================================================
/*
В этой задаче Вам требуется найти максимальную по длине подстроку данной строки, такую что каждый символ встречается в ней не более k раз.

Входные данные
В первой строке даны два целых числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ n ) , где n – количество символов в строке. Во второй строке n символов – данная строка, состоящая только из строчных латинских букв.

Выходные данные
В выходной файл выведите два числа – длину искомой подстроки и номер её первого символа. Если решений несколько, выведите любое.
Примеры
входные данные
3 1
abb
выходные данные
2 1
входные данные
5 2
ababa
выходные данные
4 1
входные данные
6 2
ababac
выходные данные
5 2
входные данные
10 2
aaaaababba
выходные данные
4 5
*/

type ItemCounter struct {
	cnt         map[byte]int
	frequentCnt int
	limit       int
}

func (itemCount *ItemCounter) add(item byte) {
	if itemCount.cnt[item] == itemCount.limit {
		itemCount.frequentCnt++
	}

	itemCount.cnt[item]++
}

func (itemCount *ItemCounter) remove(item byte) {
	itemCount.cnt[item]--

	if itemCount.cnt[item] == itemCount.limit {
		itemCount.frequentCnt--
	}
}

func (itemCount *ItemCounter) frequenItems() int {
	return itemCount.frequentCnt
}

func main() {
	var n, k int
	var str string
	fmt.Scan(&n, &k)
	fmt.Scan(&str)

	bestLen, bestFrom := 0, 1

	itemCounter := ItemCounter{cnt: make(map[byte]int), frequentCnt: 0, limit: k}

	for l, r := 0, 0; r < n; r++ {
		itemCounter.add(str[r])

		for itemCounter.frequenItems() > 0 {
			itemCounter.remove(str[l])
			l++
		}

		if r-l+1 > bestLen {
			bestLen = r - l + 1
			bestFrom = l + 1
		}
	}

	fmt.Println(bestLen, bestFrom)
}

// ---------------------------------------------
func main() {
	var n, k int
	var str string
	fmt.Scan(&n, &k)
	fmt.Scan(&str)

	frequentCnt, bestLen, bestFrom := 0, 0, 1
	cnt := make(map[byte]int)

	for l, r := 0, 0; r < n; r++ {
		if cnt[str[r]] == k {
			frequentCnt++
		}

		cnt[str[r]]++

		for frequentCnt > 0 {
			cnt[str[l]]--

			if cnt[str[r]] == k {
				frequentCnt--
			}

			l++
		}

		if r-l+1 > bestLen {
			bestLen = r - l + 1
			bestFrom = l + 1
		}
	}

	fmt.Println(bestLen, bestFrom)
}
