/*
! Риакт спроектирован так, что он независим от браузера и служит для сознания пользовательских интерфейсов, а за визуализацию и за рендеринг и отрисовку Риакт компонентов в браузере отвечает библиотека React DOM  

* Риакт компоненты - это Компоненты позволяют разделить пользовательский интерфейс на независимые, повторно используемые части и работать с каждой из частей отдельно.
* Все React-компоненты должны вести себя как чистые функции в плане своих свойств.
* каждый компонент обладает каким то состоянием и при изменении этого состояния Риакт понимает, что произошли какие то изменения и перерисовывает компонент.

! useState - один из стандартных хуков предоставляемых Риактом, для управления состоянием.
? Хуки - это некоторые функции предоставляемые нам Риактом, которые всегда начинаются со слова (use)
? и которые мы можем использовать в Функциональных компонентах или в наших собственных хуках.
* Хуки можно использовать только на вверхнем уровне вложенности функционального компонента или кастомного хука!!! (т.е. мы не можем вкладывать хуки в какие то функции, в условия, в циклы)
*/

// =========================================================================================
//! функциональный компонент
const Counter = function () {
  const [count, setCount] = useState(0); //! возвращает массив под 0: само значение, а под 1: функция изменяющая состояние

  function increment() {
    setCount(count + 1);
  }

  function dencrement() {
    setCount(count - 1);
  }

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Increment</button>
      <button onClick={dencrement}>Decrement</button>
    </div>
  );
};

// ==================================================================

// * Входные данные в контексте Риакта называются пропсами (props)
// * Свойства объекта props доступны только для чтения
const PostItem = (props) => {
  return (
    <div className="post">
      <div className="post__content">
        <strong>
          {props.post.id}. {props.post.title}
        </strong>
        <div>{props.post.body}</div>
      </div>

      <div className="post__btns">
        <button>Delete</button>
      </div>
    </div>
  );
};
// =====================================================================
const PostList = ({ posts, title }) => {
  return (
    //! В компоненте может быть только один корневой элемент
    <div>
      <h1 style={{ textAlign: "center" }}>{title}</h1>

      {posts.map((post) => (
        <PostItem post={post} key={post.id} />
      ))}
    </div>
  );
};
// =====================================================================
import "./styles/App.css"; // Импортируем наши стили (один из способов) //! Для всего приложения
import classes from "./MyButton.module.css"; // один из способов работы со стилями //! для конкретного UI компонента (кнопки)
// =====================================================================
/*
* Двухстороннее связывание - реализовали связывание состояния со значением которое находится(передано) в input. Подобные компоненты называются управляемыми поскольку мы всегда можем изменить значение этого компонента изменив его состояние.

import Counter from "./components/Counter"; // ! когда export default Counter;
import { Postitem } from "./components/Postitem"; // ! кога export function Postitem() {...}

*когда мы создаем списки обязательным условием является создание ключа, который будет хранить уникальное значение, как правило используют id объекта. Индек использовать не рекомендуется, так-как ключ должен всегда быть статичным и уникальным, чего нельзя сказать об индексах. <Postitem post={post} key={post.id} /> 
*Ключи позволяют алгоритмам Риакта наиболее эффективно делать рендеринг и перерисовывать не весь список а только те элементы где произошли изменения.

*В Компоненте может быть только один корневой элемент.
*/
/*
*Название класа генерируется в соответствии с css модулем который мы сделали. Там мы можем добитьмя изоляции стилей не используя БЭМ. MyButtom.module.css
---------------------------------------------------------------------------------------------------------------------------

*По умолчанию Риакт не знает в какое место компонента необходимо добавлять вложенные элементы. Для этого есть специальный Пропс который называется Чилдрен:
function MyButton(props) {
  return <button className={classes.myBtn}>{props.children}</button>;
}

or

function MyButton({ children, ...props }) {
  return <button className={classes.myBtn}>{children}</button>;
}

---------------------------------------------------------------------------------------------------------------------------
Хук useRef - с помощью этого хука мы можем получить доступ к DOM элементу и уже у этого DOM элемента забрать value (напрямую работа с дом деревом не желательна)

//! React.forwardRef функция обертка для возможности пеердачи ссылки при вложенности компонентов
const MyInput = React.forwardRef(function (props, ref) {
  return <input ref={ref} className={classes.MyInput} {...props} />;
});


setPosts([...posts, newPost]); //! мы не изменяем состояние напрямую а используем для этого хук. Важная концепция !!!!!!!!!!!!!


Обмен данными между компонетами:
	1) Обмен props (пропсами) идет сверху вних, от родителя к дочерним компонентам (ребенку). Передача пропсов снизу вверх не возможна. Но мы можем от родителя передать функцию колбек это поможет решить проблемму передачи данных от ребенка родителю
		function updateData(value) {
    			setMyState(value);
  		}
	2) .....

  3) Redux .....
*/
/*
* Условная отрисовка - выполнение чего то, (всплытие окна, alert с текстом сообщения и предупреждения) пример реализации с условием тенарника:
{posts.length !== 0 ? <PostList remove={removePost} posts={posts} title={"Список языков программирования:"} /> : <div>Посты не найдены!</div>}
ну или
{ posts.length !== 0 
  ? <PostList remove={removePost} posts={posts} title={"Список языков программирования:"} /> 
  : <div>Посты не найдены!</div>
}
*/

/*
Для React так не правильно. Не раотает в функции колбека код в {...} в JSX разметке:
{posts.map((post, index) => {
        <PostItem remove={remove} number={index + 1} post={post} key={post.id} />
       })}

Правильно. Ихнужно заменить на скобки (...):
{posts.map((post, index) => (
        <PostItem remove={remove} number={index + 1} post={post} key={post.id} />
      ))}

----------------------------------------------------------------------------------------------------------------------------------
Хук useMemo(callback, deps) - первым аргументом принимает функцию колбе. вторым принимает массив зависимостей. Осуществляем кэширования результата вычислений (разновидность патерна Декоратор). Нужно импортировать из React
	Переданная функция колбек должна возвращать результат каких то вычислений:
	useMemo(() => {
		return [...posts].sort(...)
	}, [переменные, поля объекта])
К примеру она поможет не отрисовывать каждый раз отсортированный массив и достанет уже отсартированный массив из кеша. Но каждый раз когда какая то из зовисимосте в массиве deps изменилась то функция вновь пересчитывает и кэширует результат вычисления.
Если массив зависимосте пустой, то функция отработает лишь единожды, запомнит результат и больше вызвана не будет.

-------------------------------------------------------------------------------------------------------------------------------------------
localeCompare - функуия используется для сравнения строк при сортировке. sort изменяет объект при вызове, по этому делаем копию [...obj]
*/

/*
    Так мы сможем извлечь и передать из переменной компоненту сразу несколько классовых стилей
    <div className={[cl.MyModal, cl.active].join(' ')}>
      <div className={cl.MyModalContent}>
        {children}
      </div>
    </div>
*/

/*
*   event.stopPropagation() - предотвращает вспылие события.

    <div className={rootClasses.join(' ')} onClick={()=> setVisible(false)}>
    С помощью stopPropagation мы предотвратили всплытие события у дочернего жлемента. И теперь нажатие на дочку не вызовит события навешанного родителю.
      <div className={cl.myModalContent} onClick={(event) => event.stopPropagation()}>
        {children}
      </div>
    </div>
*/
