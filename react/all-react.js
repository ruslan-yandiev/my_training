/*
! Риакт спроектирован так, что он независим от браузера и служит для сознания пользовательских интерфейсов, а за визуализацию и за рендеринг и отрисовку Риакт компонентов в браузере отвечает библиотека React DOM  

* Риакт компоненты - это Компоненты позволяют разделить пользовательский интерфейс на независимые, повторно используемые части и работать с каждой из частей отдельно.
* Все React-компоненты должны вести себя как чистые функции в плане своих свойств.
* каждый компонент обладает каким то состоянием и при изменении этого состояния Риакт понимает, что произошли какие то изменения и перерисовывает компонент.

! useState - один из стандартных хуков предоставляемых Риактом, для управления состоянием.
? Хуки - это некоторые функции предоставляемые нам Риактом, которые всегда начинаются со слова (use)
? и которые мы можем использовать в Функциональных компонентах или в наших собственных хуках.
* Хуки можно использовать только на вверхнем уровне вложенности функционального компонента или кастомного хука!!! (т.е. мы не можем вкладывать хуки в какие то функции, в условия, в циклы)
*/

// =========================================================================================
//! функциональный компонент
const Counter = function () {
  const [count, setCount] = useState(0); //! возвращает массив под 0: само значение, а под 1: функция изменяющая состояние

  function increment() {
    setCount(count + 1);
  }

  function dencrement() {
    setCount(count - 1);
  }

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Increment</button>
      <button onClick={dencrement}>Decrement</button>
    </div>
  );
};

// ==================================================================

// * Входные данные в контексте Риакта называются пропсами (props)
// * Свойства объекта props доступны только для чтения
const PostItem = (props) => {
  return (
    <div className="post">
      <div className="post__content">
        <strong>
          {props.post.id}. {props.post.title}
        </strong>
        <div>{props.post.body}</div>
      </div>

      <div className="post__btns">
        <button>Delete</button>
      </div>
    </div>
  );
};
// =====================================================================
const PostList = ({ posts, title }) => {
  return (
    //! В компоненте может быть только один корневой элемент
    <div>
      <h1 style={{ textAlign: "center" }}>{title}</h1>

      {posts.map((post) => (
        <PostItem post={post} key={post.id} />
      ))}
    </div>
  );
};
// =====================================================================
import "./styles/App.css"; // Импортируем наши стили (один из способов) //! Для всего приложения
import classes from "./MyButton.module.css"; // один из способов работы со стилями //! для конкретного UI компонента (кнопки)
// =====================================================================
/*
* Двухстороннее связывание - реализовали связывание состояния со значением которое находится(передано) в input. Подобные компоненты называются управляемыми поскольку мы всегда можем изменить значение этого компонента изменив его состояние.

import Counter from "./components/Counter"; // ! когда export default Counter;
import { Postitem } from "./components/Postitem"; // ! кога export function Postitem() {...}

*когда мы создаем списки обязательным условием является создание ключа, который будет хранить уникальное значение, как правило используют id объекта. Индек использовать не рекомендуется, так-как ключ должен всегда быть статичным и уникальным, чего нельзя сказать об индексах. <Postitem post={post} key={post.id} /> 
*Ключи позволяют алгоритмам Риакта наиболее эффективно делать рендеринг и перерисовывать не весь список а только те элементы где произошли изменения.

*В Компоненте может быть только один корневой элемент.
*/
/*
*Название класа генерируется в соответствии с css модулем который мы сделали. Там мы можем добитьмя изоляции стилей не используя БЭМ. MyButtom.module.css
---------------------------------------------------------------------------------------------------------------------------

*По умолчанию Риакт не знает в какое место компонента необходимо добавлять вложенные элементы. Для этого есть специальный Пропс который называется Чилдрен:
function MyButton(props) {
  return <button className={classes.myBtn}>{props.children}</button>;
}

or

function MyButton({ children, ...props }) {
  return <button className={classes.myBtn}>{children}</button>;
}

---------------------------------------------------------------------------------------------------------------------------
Хук useRef - с помощью этого хука мы можем получить доступ к DOM элементу и уже у этого DOM элемента забрать value (напрямую работа с дом деревом не желательна)

//! React.forwardRef функция обертка для возможности пеердачи ссылки при вложенности компонентов
const MyInput = React.forwardRef(function (props, ref) {
  return <input ref={ref} className={classes.MyInput} {...props} />;
});


setPosts([...posts, newPost]); //! мы не изменяем состояние напрямую а используем для этого хук. Важная концепция !!!!!!!!!!!!!


Обмен данными между компонетами:
	1) Обмен props (пропсами) идет сверху вних, от родителя к дочерним компонентам (ребенку). Передача пропсов снизу вверх не возможна. Но мы можем от родителя передать функцию колбек это поможет решить проблемму передачи данных от ребенка родителю
		function updateData(value) {
    			setMyState(value);
  		}
	2) .....

  3) Redux .....
*/
/*
* Условная отрисовка - выполнение чего то, (всплытие окна, alert с текстом сообщения и предупреждения) пример реализации с условием тенарника:
{posts.length !== 0 ? <PostList remove={removePost} posts={posts} title={"Список языков программирования:"} /> : <div>Посты не найдены!</div>}
ну или
{ posts.length !== 0 
  ? <PostList remove={removePost} posts={posts} title={"Список языков программирования:"} /> 
  : <div>Посты не найдены!</div>
}
*/

/*
Для React так не правильно. Не раотает в функции колбека код в {...} в JSX разметке:
{posts.map((post, index) => {
        <PostItem remove={remove} number={index + 1} post={post} key={post.id} />
       })}

Правильно. Ихнужно заменить на скобки (...):
{posts.map((post, index) => (
        <PostItem remove={remove} number={index + 1} post={post} key={post.id} />
      ))}

----------------------------------------------------------------------------------------------------------------------------------
Хук useMemo(callback, deps) - первым аргументом принимает функцию колбе. вторым принимает массив зависимостей. Осуществляем кэширования результата вычислений (разновидность патерна Декоратор). Нужно импортировать из React
	Переданная функция колбек должна возвращать результат каких то вычислений:
	useMemo(() => {
		return [...posts].sort(...)
	}, [переменные, поля объекта])
К примеру она поможет не отрисовывать каждый раз отсортированный массив и достанет уже отсартированный массив из кеша. Но каждый раз когда какая то из зовисимосте в массиве deps изменилась то функция вновь пересчитывает и кэширует результат вычисления.
Если массив зависимосте пустой, то функция отработает лишь единожды, запомнит результат и больше вызвана не будет.

-------------------------------------------------------------------------------------------------------------------------------------------
localeCompare - функуия используется для сравнения строк при сортировке. sort изменяет объект при вызове, по этому делаем копию [...obj]
*/

/*
    Так мы сможем извлечь и передать из переменной компоненту сразу несколько классовых стилей
    <div className={[cl.MyModal, cl.active].join(' ')}>
      <div className={cl.MyModalContent}>
        {children}
      </div>
    </div>
*/

/*
*   event.stopPropagation() - предотвращает вспылие события.

    <div className={rootClasses.join(' ')} onClick={()=> setVisible(false)}>
    С помощью stopPropagation мы предотвратили всплытие события у дочернего жлемента. И теперь нажатие на дочку не вызовит события навешанного родителю.
      <div className={cl.myModalContent} onClick={(event) => event.stopPropagation()}>
        {children}
      </div>
    </div>
*/
/*
React Transition Group - библиатека React для анимации (удобный инструмент)

import React from 'react';
import { CSSTransition, TransitionGroup} from 'react-transition-group'; // библиотека анимации, добавленная через npm
import { PostItem } from "./PostItem";

function PostList({ remove, posts, title }) {
  if (!posts.length) return <h1 style={{ textAlign: "center", color: "red" }}>Посты не найдены!</h1>

  return (
    <div>
      <h1>{title}</h1>
      <TransitionGroup>
        {posts.map((post, index) => 
          <CSSTransition key={post.id} timeout={500} classNames="post">
            <PostItem remove={remove} number={index + 1} post={post} />
          </CSSTransition>
        )}
      </TransitionGroup>
    </div>
  );
}

export default PostList;

.post-enter {
  transform: translateX(350px);
}
.post-enter-active {
  transform: translateX(0);
  transition: all 500ms ease-in;
}
.post-exit {
  opacity: 1;
}
.post-exit-active {
  transform: translateX(-350px);
  transition: all 500ms ease-in;
}

===================================================================================================
Логику по сортировке и фильтрации к примеру вынести куда то отдельно, создав Кастомные Хуки.
Все хуки должны начинаться на use...
Кастомные Хуки внутри себя используют дефолтные хуки Риакта.
*/

/*
axios - библиотека позволяющая делать запросы для Риакта
-----------------------------------------------------------------------------------------------------------------------------

Жизненный цикл Компонента:
	*Каждый компонент обладает своим жизненным циклом и он проходит в три этапа: Монтирование(mount)--> Обновление(update)--> Размонтирование(unmount)
	Монтирование(mount): Когда создается компонент и вмонтируется в DOM дерево.
	Обновление(update): обновление компонента. Например мы изменили состояние и произошол перерендер, перерисовка компонента и эта стадия называется обновление.(По сути это стадия активной жизни компонента, когда он работает, когда мы его видим, когда он живет)
	Размонтирование(unmount): Когда он больше не нужен и по какойто причине мы удаляем компонент. Например мы хотим его скрыть или переходим на другую страницу и за ненадобностью Риакт уничтожает компонент.
*Следить за жизненными циклами компонента можно с помощью хука useEffect(callback, deps) - можем использовать столько раз в компоненте сколько нам необходимо. (один следит за одними данными, другой за другими, третий отрабатывает только при первичной отрисовке...)
	useEffect(функция callback, Массив зависимостей)
	useEffect(()=> { fetchPosts() }, []) - хук отработает один раз в момент монтирования компонента. Таким образом мы можем отследить эту стадию монтирования и выполнить нужные для нас действия (к примеру отгрузить список постов).
	useEffect(()=> { fetchPosts() }, [filter]) - отработает на каждое изменение filter.
	
	useEffect(()=> { 
		fetchPosts()

		return ()=> {
			ДЕЛАЕМ ОЧИСТКУ
		} 
	}, [])					- за стадией размонтирования мы тоже можем следить. Если callback возвращает какую то функцию то эта функция будет ВЫЗВАНА в момент ДЕМОНТИРОВАНИЯ компонента. (в этот момент нужно делать всевозможные очистки, очищать глобальное хранилище, отписываться от каких то событий)	


	useEffect с использованием каких то зависимостей в массиве useEffect(callback, [зависимости]) работает точно так же как и наблюдаемые свойства во вью (вьюхе) (отображении), количество зависимостей мы можем передавать столько сколько потребуется
*/

/*
(частый кейс) обработка индикатора загрузки, обработка ошибки, и выполнение какого то колбека
export const useFetching = (callback) => {
  const [isLoading, setIsLoading] = useState(false);      // наше состояние для условия, чтобы отображать что-то пока данные подгружаются с сервера
  const [error, setError] = useState('');

  const fetching = async () => {
    try {
      setIsLoading(true);
      await callback();
    } catch(e) {
      setError(e.message);
    } finally {
      setIsLoading(false);
    }
  }

  return [fetching, isLoading, error];
}

===============================================================================================================

 
{postError && <h1>Произошла ошибка ${postError}</h1>} - интересная условная конструкция  (если, то выполнить...)

===============================================================================================================

в папке utils будем работать с датами, какими нибудь форматированиями, работа со строками, номерами страниц, вычислениями .....

===============================================================================================================
Изменение состояния это асинхронный процесс!!!! Асинхронность для изменения состояния нужнадля React(НАКАПЛИВАЕТ ИЗМЕНЕНИЯ И ПРИМЕНЯЕТ РАЗОМ, ЧТОБЫ ИЗБЕЖАТЬ ЛИШНИХ И ПОВТОРЫНЫХ МАНИПУЛЯЦИЙ С DOM)
Но это несет и свои проблеммы, если часть нашего кода будет синхронным мы увидим не совсем коректные данные, как в случае с измениением страницы при запросе постов с параметрами, страницы в данных будут отставать.

*/