package main

import "fmt"

// func maximumCount(nums []int) int {
// 	left := -1
// 	right := len(nums)
// 	var mid int
// 	l, r := 0, 0

// 	for left+1 < right {
// 		mid = (left + right) / 2

// 		if nums[mid] >= 0 {
// 			right = mid
// 		} else {
// 			left = mid
// 		}
// 	}

// 	l = left
// 	left = -1
// 	right = len(nums)

// 	for left+1 < right {
// 		mid = (left + right) / 2

// 		if nums[mid] <= 0 {
// 			left = mid
// 		} else {
// 			right = mid
// 		}
// 	}

// 	r = right

// 	l += 1
// 	r = len(nums) - r

// 	if l > r {
// 		return l
// 	}

// 	return r
// }

//	func main() {
//		fmt.Println(maximumCount([]int{-3, -2, -1, 1, 2, 3}))                                  // 3
//		fmt.Println(maximumCount([]int{-4, -3, -2, -1, 1, 2, 3}))                              // 4
//		fmt.Println(maximumCount([]int{-3, -2, -1, 1, 2, 3, 4}))                               // 4
//		fmt.Println(maximumCount([]int{-6, -5, -4, -3, -2, -1, 1, 2, 3}))                      // 6
//		fmt.Println(maximumCount([]int{-3, -2, -1, 1, 2, 3, 4, 5, 6}))                         // 6
//		fmt.Println(maximumCount([]int{-3, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3})) // 3
//		fmt.Println(maximumCount([]int{-4, -3, -2, -1, 0, 1, 2, 3}))                           // 4
//		fmt.Println(maximumCount([]int{-3, -2, -1, 0, 0, 0, 0, 1, 2, 3, 4}))                   // 4
//		fmt.Println(maximumCount([]int{-6, -5, -4, -3, -2, -1, 0, 0, 1, 2, 3}))                // 6
//		fmt.Println(maximumCount([]int{-3, -2, -1, 0, 0, 1, 2, 3, 4, 5, 6}))                   // 6
//	}

/*
Когда у Валеры появляется свободное время, он идет в библиотеку и читает книги. Вот и сегодня у него появилось t свободных минут для чтения. Поэтому Валера взял n книг в библиотеке и для каждой книги оценил: какое время потребуется, чтобы ее прочитать. Пронумеруем книги целыми числами от 1 до n. Для прочтения i-той книги Валере требуется ai минут.

Валера решил, что он выберет произвольную книгу с номером i и будет читать книги друг за другом, начиная с этой книги. Другими словами, сначала он прочитает книгу c номером i, затем книгу с номером i + 1, затем книгу с номером i + 2 и так далее. Он продолжает этот процесс до тех пор, пока либо не закончится его свободное время, либо не прочитает книгу с номером n. Каждую книгу Валера читает целиком, то есть он не читает книгу, которую не успеет дочитать до конца из-за нехватки свободного времени.

Посчитайте максимальное количество книг, которое Валера сможет прочитать.

Входные данные
В первой строке заданы два целых числа n и t (1 ≤ n ≤ 105; 1 ≤ t ≤ 109) — количество книг и количество свободных минут у Валеры соответственно. Во второй строке задана последовательность из n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 104), в которой число ai обозначает количество минут, которое требуется для прочтения i-ой книги.

Выходные данные
Выведите единственное целое число — максимальное количество книг, которое Валера сможет прочитать.
*/

// func foo(n, t int, timeCollection []int) int {
// 	for i := 1; i < len(timeCollection); i++ {
// 		for j := i; j > 0 && timeCollection[j] < timeCollection[j-1]; j-- {
// 			timeCollection[j], timeCollection[j-1] = timeCollection[j-1], timeCollection[j]
// 		}
// 	}

// 	var count, time int

// 	for _, v := range timeCollection {
// 		if time+v <= t {
// 			count++
// 			time += v
// 		}
// 	}

//		return count
//	}

/*
Берляндия в ходе войны с Флатландией начинает перехватывать инициативу. Чтобы изгнать противника с родной земли, берляндцам нужно точно знать, сколько еще флатландских солдат осталось в резерве врага. К счастью, утром разведчики взяли «языка», у которого было секретное зашифрованное сообщение с нужной берляндцам информацией.

У пойманного нашли массив целых положительных чисел. Берляндская разведка уже давно знает шифр флатландцев: чтобы передать сообщение, в котором фигурирует число m, враги используют такой массив чисел a, что количество его подмассивов, в которых есть хотя бы k одинаковых чисел, равно m. Число k давно известно всей берляндской армии, поэтому генерал Туристов снова попросил ефрейтора Васю выполнить несложное задание: расшифровать сообщение флатландцев.

Помогите Васе, по заданному массиву чисел a и числу k, найдите количество подмассивов массива чисел a, в которых есть хотя бы k одинаковых чисел.

Подмассивом a[i... j] (1 ≤ i ≤ j ≤ n) массива a = (a1, a2, ..., an) называется массив, составленный из последовательных его элементов, начиная с i-го и заканчивая j-м: a[i... j] = (ai, ai + 1, ..., aj).

Входные данные
В первой строке через пробел записаны два целых числа n, k (1 ≤ k ≤ n ≤ 4·105) — количество чисел в массиве и требуемое количество одинаковых чисел в подмассивах, соответственно.

Во второй строке через пробел записаны n целых чисел ai (1 ≤ ai ≤ 109) — элементы массива.

Выходные данные
Выведите единственное число — количество подмассивов массива a таких, что в них есть как минимум k одинаковых чисел.

Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.

Примеры
входные данныеСкопировать
4 2
1 2 1 2
выходные данныеСкопировать
3

входные данныеСкопировать
5 3
1 2 1 1 3
выходные данныеСкопировать
2

входные данныеСкопировать
3 1
1 1 1
выходные данныеСкопировать
6

входные данныеСкопировать
10 3
1 2 1 2 3 3 1 2 3 5
выходные данныеСкопировать
12

Примечание
В первом примере существует три подмассива, содержащих хотя бы два одинаковых числа: (1,2,1), (2,1,2) и (1,2,1,2).

Во втором примере существует два подмассива, содержащих три одинаковых числа: (1,2,1,1,3) и (1,2,1,1).

В третьем примере любой подмассив содержит хотя бы 1 число. Всего их 6: (1), (1), (1), (1,1), (1,1) и (1,1,1).
*/

func main() {
	var n, k int
	var arr []int
	var a int

	fmt.Scan(&n, &k)

	for i := 0; i < n; i++ {
		fmt.Scan(&a)
		arr = append(arr, a)
	}

	result := 0
	hh := make(map[int]int)

	for l, r := 0, 0; r < n; r++ {
		hh[arr[r]]++

		if hh[arr[r]] == k {
			result++
		}

		for hh[arr[l]] == k {
			hh[arr[l]]--
			result++
		}
	}

	fmt.Println(result)
}
